Thank you for your thoughtful feedback!

# Review A

> it doesn't even have fixpoint

Type holes actually allow you to express general recursion (e.g. via the Y 
combinator) - see footnote 9 and Siek and Taha [2006].

That said, we agree that an explicit fix operator might be more clear; there is
nothing that would complicate its inclusion, so if requested, we would be happy 
to include it either in the main calculus or as an extension.

> I'm still confused about which version of the language is implemented.
> Are the screenshots in section 2 real, or only the ones in the appendix?

The screenshots in the Appendix show the submitted implementation, which 
supports all of the live programming features described in Section 2 for 
the language of Section 3 plus the extensions in the appendix.

For the sake of exposition, the figures in Section 2 do depict certain language
features that were not implemented at submission (as acknowledged in the 
intro of Section 2). To create these figures, we first ran simpler variants of 
the examples (using the usual lambda encoding tricks), and then we manually
edited the resulting HTML/CSS to add in conveniences common to languages like 
ML/Elm, namely record labels, basic pattern matching and syntactic sugar for 
function definitions and lists.

For artifact evaluation, we plan to submit a more recent snapshot of the Hazel
implementation that either substantially narrows or eliminates this 
"convenience gap".

# Review C

> While, the technical development is sound, it is mostly based prior work 
> (Hazelnut type system), or a variation on gradually typed calculi, and 
> not very surprising. In fact, evaluation of expression with holes is akin 
> to evaluation of expressions with free variables extended with type casts 
> from gradual typing.

Only the external type system comes from the Hazelnut paper (reviewed in 3.1). 
That paper did not define a dynamic semantics at all. 

Unlike gradually typed lambda calculi, we do not abort immediately on cast
failure (Sec. 2.4). Moreover, we consider not just type holes but also 
expression holes, which operate not merely as free variables, as suggested, 
but as a sort of closure. Closure tracking is critical to the user experience 
throughout Sec. 2 and to the fill-and-resume feature described in Sec. 4. 

Closure tracking has a conceptual relationship with the prior work on CMTT (a 
non-obvious and satisfying logical connection, we believe!), but that work 
also did not define a dynamic semantics nor consider non-empty holes nor the 
commutativity property in Sec. 4.

We carefully combined mechanisms from these prior systems and define new 
technical infrastructure (e.g. indeterminate forms) to be able to prove 
preservation, progress and commutativity theorems mechanically. We are not 
aware of an operational semantics with comparable features and metatheory. 

> the calculus lacks recursion and control-flow. Dealing with these efficiently 
> and providing a good user interface for inspecting the resulting reified values 
> is the hard problem in making such an environment.

## Semantics for Recursion and Control Flow

Please see the discussion above regarding recursion.

The sum types extension in the appendix adds primitive control flow. With the
additional page budget, we will include this extension in the main body of the
second phase submission.

## UI

We describe our initial UI design considerations for recursion in Sec. 2.2. The
UI allows the user to explore the recursive structure of hole closures
iteratively as described in that section, rather than displaying nested hole
closures all at once, as is the case in the notation used for the core calculus.

Regarding , the UI displays a "breadcrumb" path from the result to
reflect the exploration that the user has done (the basic UI can be seen at the
bottom of Fig. 17). We would be happy to include this more prominently in the
second phase submission (it requires showing a second, more deeply nested hole
environment, so we will need the additional space available in the second phase
submission).

## Effects and Mutation

TODO

Finish on 
