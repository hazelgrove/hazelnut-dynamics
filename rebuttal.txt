
Thank you for your thoughtful feedback!

# Review A

> it doesn't even have fixpoint

Type holes actually allow you to express general recursion (e.g. via the Y 
combinator) - see footnote 9 and [Siek and Taha, 2006] on embedding the 
untyped lambda calculus.

That said, we agree that an explicit fix operator might be more clear; there is
nothing that would complicate its inclusion, so if requested, we would be happy
to make this small addition, either in the main calculus or as an extension.

> Are the screenshots in section 2 real, or only the ones in the appendix?

The screenshots in the Appendix show the submitted implementation, which 
supports all of the live programming features described in Section 2 for 
the language of Section 3 plus the extensions in Appendix B.

For the sake of exposition, the figures in Section 2 do go beyond the language
of Section 3 (as acknowledged in the intro to Section 2). To create these figures, 
we first ran simpler variants of the examples (using typical lambda encoding 
tricks) in our implementation, and then we manually edited the resulting 
HTML/CSS only to add in conveniences common to languages like ML/Elm, namely 
record labels, basic pattern matching and syntactic sugar for function 
definitions and lists.

For artifact evaluation, we plan to submit a more recent snapshot of the Hazel
implementation that either substantially narrows or eliminates this small 
"convenience gap".

# Review C

> While, the technical development is sound, it is mostly based prior work 
> (Hazelnut type system), or a variation on gradually typed calculi, and 
> not very surprising. In fact, evaluation of expression with holes is akin 
> to evaluation of expressions with free variables extended with type casts 

We disagree with this characterization.

Only the external type system comes from the Hazelnut paper (reviewed in 3.1). 
That paper did not define a dynamic semantics at all. 

Unlike gradually typed calculi, we do not abort immediately on cast failure 
(Sec. 2.4). Moreover, we consider not only type holes but also expression 
holes, which operate not merely as free variables (which, as suggested, would
be rather uninteresting), but as metavariable closures. Closure tracking is 
critical to the user experience throughout Sec. 2 and to the fill-and-resume 
feature in Sec. 4. 

Closure tracking has a relationship with the prior work on CMTT (a non-obvious 
and satisfying logical connection, we believe!), but that work also did not 
define a dynamic semantics, nor did it consider non-empty holes nor the 
commutativity property in Sec. 4.

> the calculus lacks recursion and control-flow 

Please see above regarding recursion. The sum types extension in Appendix B 
adds primitive control flow. With the additional page budget, we could move 
this extension into the main body.

> providing a good user interface for inspecting the resulting reified values 
> is the hard problem in making such an environment

We agree that both theoretical and UI considerations are worthy of substantial 
investigation. This paper focused on the former, laying detailed type-theoretic
foundations motivated by one proof-of-concept UI design and several small but 
non-trivial examples.

This UI was designed explicitly with recursion in mind in that it allows 
the user to explore the recursive structure of hole closures iteratively (Sec 2.2). 
It does not display nested hole closures all at once, as in the 
notation used in the core calculus. We say a little more below the fold.

Branches blocked on a hole can certainly "blow up" in size. A simple, partial 
solution is to visually collapse such sub-expressions by default. Because we 
define a small step semantics, another approach is to pause evaluation when 
this situation occurs and continue only if explicitly requested. Because we 
leave evaluation order undefined, the user could also explicitly shift the 
"evaluation cursor" elsewhere in such a situation.

## Effects and Mutation

TODO

-------

Regarding , the UI displays a "breadcrumb" path from the result to
reflect the exploration that the user has done (the basic UI can be seen at the
bottom of Fig. 17). We would be happy to include this more prominently in the
second phase submission (it requires showing a second, more deeply nested hole
environment, so we will need the additional space available in the second phase
submission).

