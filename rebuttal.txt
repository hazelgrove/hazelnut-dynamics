Thank you for your thoughtful reviews. We believe...


# Review A

> The HazelnutLive calculus in the paper is really basic, it doesn't even have 
> fixpoint.

Type holes actually allow you to express general recursion (e.g. via the Y 
combinator). See Siek and Taha [2006] for more on embedding the untyped lambda
calculus into a gradually typed lambda calculus like Hazelnut Live.

That said, we agree that an explicit fix operator in the style of Plotkin's PCF
might be more clear and there is nothing that would complicate its inclusion, 
so if requested, we would be happy to include it in the second phase submission, 
either in the main calculus or as another extension.

> I'm still confused about which version of the language is implemented.

The language of the submitted implementation is the language of Section 3 + 
the extensions in the appendix. We plan to archive a frozen version of that 
implementation as a simple reference implementation of the core calculus of 
this paper.

The first two paragraphs of Section 2 were, we believe, direct in stating that 
the figures in Section 2 were post-processed to use certain language features 
that were not implemented at the time of submission. None of these language 
features are particularly complex or unusual (records, simple pattern matching, 
and syntactic sugar for function definitions and lists), and they are 
orthogonal to the live programming features that are the topic of the paper, 
which are all implemented as described in Section 2 (see the implementation 
screenshots in Fig. 17-18 in the appendix).

We plan to submit a more recent snapshot of the Hazel implementation for 
artifact evaluation that either substantially narrows or eliminates this 
``convenience gap''. 

Our approach has been to...

# Review C

> While, the technical development is sound, it is mostly based prior work 
> (Hazelnut type system), or a variation on gradually typed calculi, and 
> not very surprising. In fact, evaluation of expression with holes is akin 
> to evaluation of expressions with free variables extended with type casts 
> from gradual typing.

We certainly build directly upon the Hazelnut paper, as reviewed in Sec. 3.1, 
but that paper did not define a dynamic semantics at all. 

Gradually typed lambda calculi consider only type holes, and cast failure 
immediately aborts evaluation. We do not abort immediately (Sec. 2.4). Moreover,
we consider not just type holes but also expression holes, which operate not 
merely as free variables, as suggested, but as closures. Closure tracking is 
critical to the user experience in Sec. 2 and to the fill-and-resume feature 
described in Sec. 4. 

Closure tracking has a conceptual relationship with prior work on CMTT 
(a non-obvious insight, we believe!), but that work also did not define an
operational semantics nor consider the commutativity property in Sec. 4.

So the novelty is in carefully combining all three of these pieces of prior work 
and then defining the necessary technical infrastructure (e.g. indeterminate 
forms) to be able to prove preservation, progress and commutativity theorems. 
We are not aware of any comparable related work.

> the calculus lacks recursion and control-flow. Dealing with these efficiently 
> and providing a good user interface for inspecting the resulting reified values 
> is the hard problem in making such an environment.

## Recursion

See the response to Review A above regarding recursion in the core calculus. 

We also considered the topic of recursion in Sec. 2.2 (Example 2: Recursive 
Functions). The UI was designed with recursion in mind in that it allows the 
user to explore the recursive structure of hole closures iteratively as 
described in that section, rather than displaying nested hole closures all at
once, as is the case in the notation used for the core calculus. 

The UI displays a "breadcrumb" path from the result to reflect the exploration 
that the user has done (the basic UI can be seen at the bottom of Fig. 17). We 
would be happy to include this more prominently in the second phase submission 
(it requires showing a second, more deeply nested hole environment, so we will
need the additional space available in the second phase submission).

## Control Flow

The sum types extension in the appendix also adds
primitive control flow. With the additional page budget, we will include this
extension in the main body of the second phase submission.

## Novelty


