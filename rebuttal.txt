Thank you for your thoughtful comments, all of which will be incorporated in our
revision.


# Review A

> I'm still confused about which version of the language is implemented.
> Are the screenshots in section 2 real, or only the ones in the appendix?

The submitted implementation supports the language of Section 3 plus the
extensions in the appendix. The screenshots in the Appendix show the 
implementation at the time of submission.

All live programming features described in Section 2 are implemented. However,
the figures in Section 2 do depict certain language conveniences that were not 
implemented at the time of submission (per the intro of Section 2). To create 
the figures, we first ran simpler versions of the examples (using encodings 
based on the core calculus), and then we manually post-processed the resulting 
HTML/CSS of the editor to depict standard conveniences common to languages like 
Elm and ML, e.g. records, basic pattern matching and syntactic sugar for 
function definitions and lists.

For artifact evaluation, we plan to submit a more recent snapshot of the Hazel
implementation that either substantially narrows or eliminates this 
"convenience gap".

> The HazelnutLive calculus in the paper is really basic, it doesn't even have 
> fixpoint.

Type holes actually allow you to express general recursion (e.g. via the Y 
combinator). See Siek and Taha [2006] for more on embedding the untyped lambda
calculus into a gradually typed lambda calculus like Hazelnut Live.

That said, we agree that an explicit fix operator might be more clear; there is
nothing that would complicate its inclusion, so if requested in our revision, we
would be happy to include it either in the main calculus or as an extension.


# Review C

> While, the technical development is sound, it is mostly based prior work 
> (Hazelnut type system), or a variation on gradually typed calculi, and 
> not very surprising. In fact, evaluation of expression with holes is akin 
> to evaluation of expressions with free variables extended with type casts 
> from gradual typing.

We certainly build directly upon the Hazelnut paper, as reviewed in Sec. 3.1, 
but that paper did not define a dynamic semantics at all. 

Gradually typed lambda calculi consider only type holes, and cast failure 
immediately aborts evaluation. We do not abort immediately (Sec. 2.4). Moreover,
we consider not just type holes but also expression holes, which operate not 
merely as free variables, as suggested, but as closures. Closure tracking is 
critical to the user experience in Sec. 2 and to the fill-and-resume feature 
described in Sec. 4. 

Closure tracking has a conceptual relationship with prior work on CMTT 
(a non-obvious insight, we believe!), but that work also did not define an
operational semantics nor consider the commutativity property in Sec. 4.

So the novelty is in carefully combining all three of these pieces of prior work 
and then defining the necessary technical infrastructure (e.g. indeterminate 
forms) to be able to prove preservation, progress and commutativity theorems. 
We are not aware of any comparable related work.

> the calculus lacks recursion and control-flow. Dealing with these efficiently 
> and providing a good user interface for inspecting the resulting reified values 
> is the hard problem in making such an environment.

## Recursion

See the response to Review A above regarding recursion in the core calculus. 

We also considered the topic of recursion in Sec. 2.2 (Example 2: Recursive 
Functions). The UI was designed with recursion in mind in that it allows the 
user to explore the recursive structure of hole closures iteratively as 
described in that section, rather than displaying nested hole closures all at
once, as is the case in the notation used for the core calculus. 

The UI displays a "breadcrumb" path from the result to reflect the exploration 
that the user has done (the basic UI can be seen at the bottom of Fig. 17). We 
would be happy to include this more prominently in the second phase submission 
(it requires showing a second, more deeply nested hole environment, so we will
need the additional space available in the second phase submission).

## Control Flow

The sum types extension in the appendix also adds
primitive control flow. With the additional page budget, we will include this
extension in the main body of the second phase submission.

## Novelty


