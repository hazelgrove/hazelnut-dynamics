Thank you for your thoughtful comments, all of which will be incorporated in our
revision.


# Review A

> I'm still confused about which version of the language is implemented.
> Are the screenshots in section 2 real, or only the ones in the appendix?

The submitted implementation supports the language of Section 3 plus the
extensions in the appendix.

The screenshots in Section 2 are mockups, depicting language features that were
not implemented at the time of submission. To create the screenshots in Section
2, we first ran simpler versions of the examples (using encodings based on the
core features), and then we manually post-processed the resulting HTML/CSS of
the editor to obtain the mockups. The screenshots in the Appendix show the
implementation at the time of submission. We will make this explanation even
clearer in our revision.

For artifact evaluation, we plan to submit a more recent snapshot of the Hazel
implementation that either substantially narrows or eliminates the
``convenience gap'' between the core language and the features depicted in
Section 2.

> The HazelnutLive calculus in the paper is really basic, it doesn't even have 
> fixpoint.

Type holes actually allow you to express general recursion (e.g. via the Y 
combinator). See Siek and Taha [2006] for more on embedding the untyped lambda
calculus into a gradually typed lambda calculus like Hazelnut Live.

That said, we agree that an explicit fix operator might be more clear; there is
nothing that would complicate its inclusion, so if requested in our revision, we
would be happy to include either in the main calculus or as an extension.


# Review B

(nothing to say, maybe just acknowledge the typos? remove this section entirely?)

# Review C

> the calculus lacks recursion and control-flow. Dealing with these efficiently 
> and providing a good user interface for inspecting the resulting reified values 
> is the hard problem in making such an environment.

## Recursion

See the response to Review A above regarding recursion in the core calculus. 

We also considered the topic of recursion in Sec. 2.2 (Example 2: Recursive 
Functions). The UI was designed with recursion in mind in that it allows the 
user to explore the recursive structure of hole closures iteratively as 
described in that section, rather than displaying nested hole closures all at
once, as is the case in the notation used for the core calculus. 

The UI displays a "breadcrumb" path from the result to reflect the exploration 
that the user has done (the basic UI can be seen at the bottom of Fig. 17). We 
would be happy to include this more prominently in the second phase submission 
(it requires showing a second, more deeply nested hole environment, so we will
need the additional space available in the second phase submission).

## Control Flow

The sum types extension in the appendix also adds
primitive control flow. With the additional page budget, we will include this
extension in the main body of the second phase submission.

## Novelty

> While, the technical development is sound, it is mostly based prior work (Hazelnut type system), or a variation on gradually typed calculi, and not very surprising. In fact, evaluation of expression with holes is akin to evaluation of expressions with free variables extended with type casts from gradual typing.

...
