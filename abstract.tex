% !TEX root = hazelnut-dynamics.tex

\begin{abstract}

  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PAR 1: Live programming environments --- Problem statement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
\emph{Live programming environments} aim to provide programmers (and sometimes audiences) 
with continuous feedback about a program's dynamic behavior as it is being edited. 
%
The problem is that programming languages typically assign dynamic meaning only 
 to programs that are \emph{complete}, i.e. syntactically well-formed and free
of type errors, whereas 
%
during much of the editing process, the program is not yet complete. As a result,  
live feedback flickers in and out or goes stale, 
in many cases for substantial lengths of time.
%
% Defining a semantics for incomplete functional programs would help bridge the
% gap between well-formed states and allow live programming environments to
% provide continuous, uninterrupted, and meaningful feedback.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PAR 2: This paper's approach: New (dynamic) semantics for incomplete programs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This paper confronts this problem from type-theoretic first principles by developing a 
\emph{dynamic semantics for incomplete functional programs}, 
based in part on the static semantics for incomplete functional programs
developed in recent work by \citet{popl-paper}. 
%
We model incomplete functional programs as expressions with \emph{holes}, 
with empty holes standing for missing expressions or types, and  non-empty holes 
operating as ``membranes'' around static and dynamic type inconsistencies. 
%
Rather than aborting with an exception when evaluation encounters any of these holes (as in
several existing systems), evaluation proceeds ``around'' the holes,
performing as much of the remaining computation as is possible and tracking the 
closure around each hole instance as it flows through the program. Various editor services can report information from these hole closures 
to help the programmer decide how to fill a hole. 
They also enable a ``fill-and-resume'' feature that 
avoids the need to restart evaluation after edits that amount to hole filling. 
Formally, the semantics draws from both gradual type theory (to handle
type holes) and contextual modal type theory (which provides a
logical foundation for hole closures), and develops additional technical machinery necessary 
to continue evaluation past the various hole forms and to prove important metatheoretic properties. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PAR 3: We have an implementation, and have proofs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% , including 
% (1) a type safety property that accounts for expression holes (i.e. free metavariables, 
% from the perspective of CMTT) and cast failure holes (which provide a novel), and (2) a commutativity property that establishes that the
% ``edit-and-resume'' feature is sound.
%
We have mechanized the core formal development using the Agda proof assistant.
%
We also describe a simple implementation, called \HazelnutLive{},
that inserts holes as
necessary during the editing process to guarantee that every edit state has some (possibly incomplete)
type, based in part on the \Hazelnut edit action calculus in prior work by \citet{popl-paper}.
%
Taken together with the type safety property that this paper establishes, the result is 
a proof-of-concept live typed functional programming environment where dynamic feedback 
is truly continuous, i.e. it is available for every possible edit state.
% i.e. \emph{every edit state is guaranteed to have
% non-trivial static and dynamic meaning}.

%In our system, evaluation treats failed casts much like it treats expression holes (rather than immediately failing with a cast error, as in gradual type theory). Prior work on contextual modal type theory did not develop an operational semantics for programs with free metavariables, which correspond to programs with holes in our formulation. 


% These incomplete edit states are sometimes transient, but at other times, they persist for extended periods of time, e.g. when the programmer is filling in the branches of a large case analysis one-by-one, or when an edit causes type errors to appear throughout a program. %This gap can cause live programming services to lag behind the programmer's edits, in many cases for an extended period of time.
\end{abstract}
