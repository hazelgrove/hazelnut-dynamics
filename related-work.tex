% !TEX root = hazelnut-dynamics.tex
\newcommand{\relatedWorkSection}{Related Work}
\section{\protect\relatedWorkSection} % don't like the all-caps thing that the template does, so protecting it from that
\label{sec:relatedWork}

Program editors frequently encounter program text that is not well-formed with
respect to the concrete syntax of the language \cite{popl-paper}.
%
Within the simplest editors, editor services that take well-formed program text
or an abstract syntax tree as input are simply disabled when this occurs.
%
More sophisticated editors, including those generated by modern editor
generators like Spoofax \cite{DBLP:conf/oopsla/KatsV10}, deploy \emph{error
recovery} heuristics that silently insert tokens or discard tokens from the
program so that the editor-internal representation is a standard abstract syntax
tree
\cite{DBLP:journals/siamcomp/AhoP72,charles1991practical,graham1979practical,DBLP:conf/oopsla/KatsJNV09}.
%
These heuristics are typically defined manually by the grammar designer, though
certain heuristics can be generated semi-automatically by tools that are given a
description of the scoping conventions of the language and of secondary
notational conventions (\eg{}~whitespace conventions)
\cite{DBLP:conf/oopsla/KatsJNV09,DBLP:conf/sle/JongeNKV09}.
%
These error recovery heuristics require guessing at the programmer's intent, and
result in tokens being inserted or deleted from the program invisibly, so they
are \emph{ad hoc} and can confuse the programmer
\cite{DBLP:conf/oopsla/KatsJNV09}.

\parahead{Hole-Driven Development}

A cleaner alternative approach, and the approach that is central to our proposed
research, is to add \emph{holes} to both the concrete and abstract syntax of the
language.
%
Syntax trees with holes first arose in prior work on \emph{structure editors},
which are program editors where every edit action directly causes changes to the
abstract syntax tree of the program, rather than going indirectly through a
parser.
%
Structure editors have a long history: the Cornell Program Synthesizer was
developed in the early 1980s \cite{teitelbaum_cornell_1981} and there has been a
steady stream of new designs in this space
(\eg{}~\cite{ko_barista:_2006,Resnick:2009:SP:1592761.1592779,voelter_mbeddr:_2012,tillmann_touchdevelop:_2011,lamdu,ActiveCodeCompletion,Greenfoot,Deuce}).
%
For example, Scratch and other block-based editors have achieved success as a
tool for teaching children how to program
\cite{Resnick:2009:SP:1592761.1592779}. \texttt{mbeddr} is an editor for a
C-like language \cite{voelter_mbeddr:_2012}, built using the commercially
supported MPS structure editor workbench \cite{voelter2011language}, that is
presently deployed to a number of customers.
%
TouchDevelop is a structure editor for an object-oriented language designed for
use on mobile devices \cite{tillmann_touchdevelop:_2011}. Lamdu \cite{lamdu},
Unison \cite{unison} and  isomorf~\cite{isomorf} are open source structure
editors for functional languages similar to ML.

%% There is reason to be optimistic, however, with recent studies 
%% suggesting that programmers experienced with a modern keyboard-driven structure editor like \texttt{mbeddr} 
%% can be highly productive \cite{DBLP:conf/vl/Asenov014,DBLP:conf/sle/VolterSBK14}.

Nevertheless, text-based program editors continue to dominate in practice, in
part because text is flexible and familiar and because tools for interacting
with text, like regular expressions and various differencing techniques used by
version control systems, are already very well-developed.
%
Consequently, researchers have also explored various ``hybrid'' approaches,
which incorporate holes into an otherwise text-based program editor.
%
For example, recent iterations of the Glasgow Haskell Compiler (GHC)
\cite{GHCWIKI}, as well as the dependently typed proof assistants
Idris~\cite{brady2013idris} and Agda~\cite{norell2009dependently}, support a
workflow where the programmer places holes manually at locations in the program
that remain under construction. Agda and Idris also allow the programmer to put
terms inside holes, to indicate that the term may not yet be well-typed or
otherwise finished.
%
Recent work on \emph{syntactic placeholders} takes some of the tedium out of
this approach by providing low-level edit actions that cause these holes (called
placeholders in their paper) to be inserted automatically \cite{Amorim2016}. 
%
This approximates the experience of a structure editor in common usage, while
allowing the programmer to perform arbitrary text edits when necessary.
%
Expression holes also appear in the context of program synthesis, serving as
placeholders in \emph{templates}~\cite{srivastava2013template} or
\emph{sketches}~\cite{solar2009sketching} to be filled in by an expression
synthesis engine.

\begin{itemize}
	%% \item Agda
	%% \item Idris
	%% \item GHC holes
	%% \item Visual Studio (and others) support for edit-and-resume
	\item Scratch lets you just skip over statement holes
	\item papers that show up in a search for ``typed holes'' -- \url{https://scholar.google.com/scholar?hl=en&as_sdt=0%2C39&q=%22typed+holes%22&btnG=}
\end{itemize}

\parahead{Structure Editor Calculus}

Most work on structure editors has focused on the user interfaces that they
present. This is important work---presenting a fluid user interface involving
exclusively structural edit actions is a non-trivial problem that has not yet
been fully resolved, though recent studies have started to show productivity
gains for keyboard-driven structure
editors~\cite{DBLP:conf/vl/Asenov014,DBLP:conf/sle/VolterSBK14}.

We emphasize
that our proposed contributions will be relevant no matter how holes come to be
inserted into the program. % We will say more about all of these systems later. 

two main remaining questions (beyond scaling up the calculus) are how to run
programs with type and expression holes.

\begin{itemize}
	\item Hazelnut paper
\end{itemize}

\parahead{Gradual Typing}

As already discussed in Track 1, type holes are closely related to the unknown
types of gradual type theory \cite{Siek06a}. This has implications for our
dynamic semantics as well---we need to be able to run programs where type holes
have obscured a type inconsistency, \eg{}~\li{let f(g : }\ \li{) => g 3 in f 4}.
This term is well-typed according to the static semantics of Track 1 because the
argument \li{g} of \li{f} has an unknown type, and so it can be applied to
\li{3}, but when \li{f} is applied to \li{4}, there is a problem because \li{4 3}
is meaningless. There are two ways to address the problem. The first is to
apply ML-style type inference to discover a more specific type schema for
\li{g}, \ie{}~that it must actually be an arrow type, and then mark the argument
\li{4} to \li{f} as a type inconsistency using a non-empty hole. We will
investigate this in Track 1. The second approach is to adopt run-time cast
insertions from research on gradual type theory. We will investigate this second
approach in Track 2. 

\begin{itemize}
	\item gradual typing (and dynamic typing)
  \item siek and taha paper
  \item snapl15 paper
  \item gradualizer paper
  \item maybe other things, e.g. several papers by ron garcia
\end{itemize}

\parahead{Contextual Modal Type Theory}

compared to the dynamics of type holes (which are based on Grad Typing), the
dynamics of expression holes are less clear.

Formally, expression holes in our proposed dynamics are closely related to the
metavariables of contextual modal type theory (CMTT) \cite{Nanevski2008}.
Metavariables in CMTT are associated with both a type and a typing context.
Expression holes can similarly be assigned a most specific type and typing
context. The environment tracking service can then be understood as being
related to the concept of a \emph{metavariable closure} in CMTT, which consists
of a metavariable paired with a substitution for all of the variables in the
typing context associated with that metavariable. Indeed, this neatly explains
the difference between our proposed dynamics and existing work on staging and
partial evaluation---that existing work is rooted in modal type theory
\cite{Davies:2001op} rather than the derivative contextual modal type theory
(which, to date, has been studied far less extensively.) In other words,
existing systems are focused on partial evaluation with respect to an input to a
function, whereas holes can appear in context, \eg{}~directly within the body of
a function. Recent work on the Beluga theorem prover is also based on CMTT,
albeit for the purpose of proof refinement and contextual reasoning rather than
program evaluation \cite{DBLP:conf/flops/Pientka10,pientka2015inductive}.
McBride's OLEG is another system for reasoning contextually about metavariables
\cite{DBLP:phd/ethos/McBride00}, and it is the basis of certain analagous
features of Idris \cite{brady2013idris}.

\begin{itemize}
	\item CMTT
\end{itemize}

\parahead{Evaluation Order}

\begin{itemize}
	\item full beta reduction
	\item prior work on confluence for the lambda calculus
	\item ``Call-by-value is dual to call-by-name'' might be relevant? \url{http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf}
	\item mention how unspecified evaluation order is something that people do when talking about parallelism?
\end{itemize}

\parahead{Partial Evaluation and Symbolic Execution}

\begin{itemize}
	\item work on partial evaluation and staging (incl. connections to modal logic -- ``modal analysis of staged computation'')
	\item symbolic evaluation
	\item maybe also search for ``partial programs'' 
\end{itemize}

put Seidel here

\parahead{Debugging}

\begin{itemize}
	\item work on debuggers that allow you to inspect environments
  \item might be something relevant in the paper ``A Debugger for Standard ML'' 
  \item "Visualizing the evaluation of functional programs for debugging" by Whitington and Ridge
  \item "A lightweight interactive debugger for Haskell'' and ``Multiple-View Tracing for Haskell: a New Hat'' might be relevant
  \item ocamli -- \url{https://github.com/johnwhitington/ocamli}
  \item Better supporting debugging aids learning a novel programming language. -- Scaffidi at VLHCC 2017
  \item quote from Wadler in ``Why no one uses functional languages'':
    \begin{quote}
    “...there are few debuggers or
profilers for strict [functional] languages, perhaps because constructing them is not considered
research. This is a shame, since such tools are sorely needed, and there remains much of
interest to learn about their construction and use.
    \end{quote}
   \item edit-and-resume in visual studio, others
\end{itemize}

Visual Studio edit-and-continue \url{https://docs.microsoft.com/en-us/visualstudio/debugger/edit-and-continue}

Hole-like constructs also appear in work on program slicing
\cite{DBLP:conf/icfp/PereraACL12}, where holes are \rkc{dynamically inserted...}

\parahead{Others?}

\begin{itemize}
	\item simply typed underdeterminism paper
	\item DuctileJ stuff -- \url{https://homes.cs.washington.edu/~mernst/pubs/ductile-icse2011.pdf}
	\item ``Achieving flexibility in direct-manipulation programming environments by relaxing the edit-time grammar'' -- \url{http://ieeexplore.ieee.org/document/1509511/}
	\item talk about closures in environmental semantics
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2018.04.14
%
% MATT MOVED THIS MATERIAL HERE FROM calculus.tex
%
% We should discuss this stuff, but IMO, it should not be necessary to
% read or appreciate these connections to understand calculus.tex on a
% first read.  These details are very interesting, but shouldn't be in
% the main technical section, IMO.
%
\subsection{MOVED FROM: Dynamic Semantics}

\matt{This discussion relates our design to CMTT; if we leave it in
  the paper, we should leave it in this section, whose point is to be
  comparative; the technical sections lack a sufficent ``attention
  budget'' for the reader to wade through this discussion as they are
  still learning the details of our paper.  Even for a really studious
  reader that already knows CMTT, I still think it makes more sense
  (organizationally) to give a detailed comparison here, and not
  there.}

To recap, the result of expansion is a well-typed internal expression with hole closures and casts, 
where the former corresponds to metavariable closures from CMTT \cite{Nanevski2008}, 
and the latter corresponds to casts from gradual type theory \cite{Siek06a,DBLP:conf/snapl/SiekVCB15}. 
However, the dynamic semantics for \HazelnutLive does not simply ``fall out'' from these observations.
%
For further discussion, see \Secref{sec:related}

The problem is first that \citet{Nanevski2008} defined only the logical reductions for CMTT, viewing it as a proof system for intuitionistic contextual modal logic via the propositions-as-types (Curry-Howard) principle. 
The paper therefore proved only a subject reduction property (which is closely related to type preservation). 
This is not a full dynamic semantics, and in particular, there is no notion of \emph{progress}, i.e. that well-typed terms cannot get ``stuck'' in an undefined state \cite{wright94:_type_soundness}. 
In any case, a conventional dynamic semantics for CMTT would not be immediately relevant to our goal of evaluating incomplete programs because, by our interpretation of hole closures, we would need a dynamic semantics for terms with free metavariables. 
\citet{Nanevski2008} sketched an interpretation of CMTT into the simply-typed lambda calculus with sums under permutation conversion%
\footnote{Permutation conversions are necessary to encode the commuting reductions of CMTT, which in turn are necessary to prove a strong normalization property. These issues are not relevant in \HazelnutLive because, as in the gradually typed lambda calculus, type holes admit non-termination: we can express the Y combinator as $(\halam{x}{\tehole}{x(x)}) (\halam{x}{\tehole}{x(x)})$.}, 
which has been studied by \citet{DBLP:journals/iandc/Groote02}, 
but under this interpretation an analogous problem arises---metavariables become variables of a function type, so again we cannot rely on the standard notion of progress on closed terms.\todo{citations}{}% We also cannot rely on, for example, weak head normalization because \HazelnutLive admits non-termination (due to casts).\todo{citation} 

Furthermore, we need to integrate casts into the dynamic semantics. 
Fortunately, the dynamic semantics for the cast calculus from the gradually typed lambda calculus provides most, but not all, of the necessary machinery. 
The first problem is again with progress: in the cast calculus, the only irreducible terms of hole type are casts, which are accounted for by the progress theorem, but in $\HazelnutLive$, holes induce additional irreducible terms. 
The second missing piece is that in prior work on casts, evaluation aborts when cast failure occurs. 
Our goal, as discussed in Sec.~\ref{sec:failed-cast-example}\todo{where?}{}, is for cast failure to instead insert a membrane around the dynamic type error, 
much like a non-empty hole serves as a membrane around a static type error, 
allowing in both cases for evaluation to safely and meaningfully continue past the error when desired.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2018.04.15
%
% MATT MOVED THIS MATERIAL HERE FROM calculus.tex
%
\subsection{MOVED FROM: Fill-and-resume}

\matt{This discussion relies on a more developed exposition of CMTT
  that we have/will give in this paper; we should leave it in this
  section, or remove it}

So far, we have understood hole filling as an extralinguistic operation. 
%
However, a key feature CMTT that we have not yet touched on is the
\emph{internalization} of metavariable binding and contextual
substitution via the contextual modal types, $[\hGamma]\htau$, which
are introduced by the operation $\mathsf{box}(\hGamma.d)$ and
eliminated by the operation $\mathsf{letbox}(d_1, u.d_2)$.
%
A hole filling can be interpreted as an expression of contextual modal
type, and the act of hole filling followed by evaluation to the next
possibly-indeterminate edit state as evaluation under the binder of a
suitable $\mathsf{letbox}$ construct, which is enabled by the dynamic
semantics in Sec.~\ref{sec:calculus}.
%
This interpretation allows us to \emph{compute} hole fillings, rather
than simply stating them, by specifying non-trivial expressions of
modal type.
%
This could serve as the basis for a \emph{live} computational hole
refinement system, extending the capabilities of purely static hole
refinement systems like those available in some proof assistants,
e.g. the elaborator reflection system of Idris
\cite{brady2013idris,DBLP:conf/icfp/ChristiansenB16} and the tactic
system\todo{right? read a bit more}{} of Beluga
\cite{DBLP:conf/flops/Pientka10,pientka2015inductive}.
%
Each applied hole filling serves as a boundary between dynamic
\emph{edit stages}.
%
This contextual modal interpretation of live staged hole refinement
nicely mirrors the modal interpretation of staged argument evaluation
\cite{Davies:2001op}.
%
We leave further development of this interpretation of hole refinement
to future work.

\subsubsection{Fill-and-resume example}

\matt{I think this example is intended to illustrate some point, but I
  could not discern what that point was}

As an example, consider two edits, the first filling a hole~$u$ with
the number~$2$, and the next applying operator~$+$, resulting in $2
+ \dehole{v}{\sigma}{}$.
%
This second edit is not a hole filling edit with respect to the
immediately preceding edit state, but it can be understood as filling
hole $u$ with $2 + \dehole{v}{\sigma}{}$. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5

\matt{This thought seems to rely on a more developed exposition of
  CMTT that we have/will give in this paper; we should leave it in
  this section, or remove it}

Another related case arises in lab notebook interfaces like that of
Jupyter/IPython \cite{PER-GRA:2007}.
%
In this case, each cell can be understood as a series of \li{let}
bindings ending in a hole, which is filled by the next cell.
%
The result from each cell can be cached to avoid recomputing the
environment from preceding cells. This contextual modal interpretation
of lab notebook cells (and read-eval-print loops as a restricted case
where edits to previous cells are impossible) is novel.

\subsubsection{Unmoored notes}

 \matt{Will any reader actually wonder this? Other than the definition
   of substitution in Section 4, does this thought connect to any
   other statement elsewhere in the paper?}

This case shows why we cannot interpret a non-empty hole as an empty
hole of arrow type applied to the enveloped expression---the hole
filling operation would not operate as expected under this
interpretation.
