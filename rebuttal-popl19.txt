Thank you for the thoughtful feedback!

# Review A 

We expect that even when writing functions much larger and more sophisticated
than qsort, programmers will still prefer to work with small example inputs like
those that might appear in documentation rather than very large inputs, which
are too unwieldy for humans to meaningfully inspect. Of course, once a function
is complete, Theorems 3.11-3.13 imply that the programmer can pass in much
larger inputs without incurring run-time overhead.

Having said that, we certainly agree that when the programmer does manage to
produce an incomplete result containing a large number of hole closures or large
indeterminate forms, there arise interesting scalability challenges related both
to the UI and, for _very_ large results, run-time cost and memory usage. 

There is a brief discussion of some of the UI scalability challenges on p25
(lines 1184-1191), but this appears perhaps confusingly in the "Structure
Editors" section. In the final paper, we will break out this discussion of
Scalability Challenges into its own section and briefly expand on it, in
particular to mention the topic of optimizing the run-time representation of
hole closures and indeterminate forms as an avenue for future work. The
formalism in this paper can serve as the baseline correctness specification for
this sort of performance optimization research.

# Review B

The proof of Theorem 4.2 (see supplement) does not actually require formalizing
the notion that "evaluation order does not matter" -- this point was perhaps not
clear from the text on p21, so we will clarify this in the final paper.

TODO: other stuff from Review B

# Review C

> When, if even, does type checking of the initial program fail?

In Hazel(nut), the Sensibility invariant (Prop. 3.14) implies that typechecking
never fails (i.e. there are no gaps in the static semantics).

> Term expansion and type checking from the theory seem slow

The Sensibility invariant also implies that the program is not typechecked anew
on each edit. Instead, the edit actions themselves enforce well-typedness by
inserting holes as necessary.

The expander is a simple single-pass function over the syntax tree, so in
programs with any non-trivial control flow, the cost of evaluation will far
exceed the cost of expansion. Expansion is compositional so for edits that
amount to hole filling (which would then be subject to the fill-and-resume
operation), only the expansion of the hole filling needs to be computed anew. We
would be happy to emphasize these points in the new Scalability Challenges
discussion section mentioned in the response to Review A above.

> a user study seems to be needed to evaluate the claim made in this paper that
> Hazelnut Live aids program development

Our claim in this paper is that substantially more information about run-time
behavior can be made available to programmers during the programming process by
combining concepts from the Hazelnut calculus, gradual type theory and CMTT. The
extent to which this information can be made useful to programmers by presenting
it at the right time and place and in the right format is an open question
worthy of substantial additional human factors research. Lines 1180-1183 state
that "we make no empirical claims regarding the usability of the particular user
interface presented in this paper. The Hazel user interface as presented is
a proof of concept [...]".

This disclaimer is again perhaps confusingly buried under the Structure Editors
heading at the end of the paper. In the final paper, we will more clearly state
in the introduction that a comprehensive treatment of the question of how best
to present the additional information that our semantics generates to human
programmers remains an open question. We anticipate that there will be many
possible designs rooted in the semantics developed in this paper, as suggested
in the conclusion of the paper. We do plan to conduct user studies in the future
as Hazel develops further and is slowly integrated into classroom settings, but
this is, as Review B suggests, part of a much longer term vision.

# Review D TODO: stuff from review D

