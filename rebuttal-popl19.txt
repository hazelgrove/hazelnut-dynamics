Thank you for your thoughtful feedback!

# A

We expect that even while writing functions much larger than `qsort`,
programmers will prefer small example inputs (like those in documentation)
because very large inputs are difficult for humans to meaningfully inspect. Once
complete, Theorems 3.11-3.13 imply no further overhead.

That said, we agree that when an indeterminate result is large or contains many hole
closures, scalability challenges could arise. In the final paper, we will pull out 
the discussion of UI scalability challenges from Line 1184 and combine it with a brief
acknowledgement of memory overhead and other performance challenges to form a  Scalability Challenges subsection in Sec. 5.

# B

The proof of Theorem 4.2 does not require formalizing the
notion that "evaluation order does not matter", so we left that
discussion to the supplement. We will clarify.

Siek and Taha (2006) defined two application rules. Matching consolidates these.

By "essentially standard...", we mean that Complete Progress coincides with
Progress for STLC (i.e. no mention of boxedval or indet).

X is complete when there are no holes or failed casts in X (Line 884). Complete expressions cannot be indeterminate.

# C

> When, if even, does type checking of the initial program fail?

In Hazel(nut), Sensibility (Proposition 3.14) implies that typechecking never
fails.

> Term expansion and type checking from the theory seem slow

Sensibility also implies that the typechecker does not run per edit -- edit
actions insert holes as necessary.

Expansion is a simple single pass, so the cost of evaluation dominates in programs with non-trivial control flow.

> a user study seems to be needed to evaluate the claim made in this paper that
> Hazelnut Live aids program development

Our claim is only that substantially more information about 
incomplete programs can be made available by combining
concepts from Hazelnut, GTLC and CMTT. The question of how to best
present this information to humans will require 
further human factors research. Line 1180 states "we make no
empirical claims [...] The Hazel user interface as presented is a proof of
concept [...]". We will make this clear in the final introduction. We do plan
to study Hazel in classrooms, but this is, as B suggests, part of a long-term research program. We hope that there will be many designs rooted in these semantics.

# D

Once we make the non-obvious observation that combining Hazelnut+GTLC+CMTT can address the gap problem, many (but not all) technical details do "fall out" naturally, but we consider this a strength of our paper!

> Why do you borrow typing rules from CMTT?

The observation is that metavariable closures from CMTT correspond to expression hole closures, which enable various services, namely the live context inspector and fill-and-resume.

> Isn't one of those unnecessary?

We need to substitute inside to evaluate inside non-empty holes. To later perform hole filling, we also need to record the substitution.

> partial evaluation

We discussed partial evaluation briefly on Line 1102, but we agree that further
discussion, specifically of the concept of residuals, is warranted in the final
version.

---

TODO: answer these below the 500 word fold? 

# Review A



# Review B 

> In several places starting on page 15: "disequal"? Do you mean "unequal"? Or
> do you mean something else? If the latter, then please define what is meant.

TODO

> Is there a reason you do not state Finality as "If d final then there exists
> no d' such that d |-> d'"?

TODO

> Why does evaluation not stop if a cast fails. Shouldn't evaluation await the
> programmer in this case?

TODO

> The conclusion of Theorem 3.12 should be that "either there exists a d' such
> that d |-> d' or d val".

TODO

> more editor states are meaningful? More that what?

TODO


