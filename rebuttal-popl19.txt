Thank you for the careful readings and thoughtful feedback!

# Review A 

We expect that even when using live programming services to write functions far
more sophisticated than qsort, programmers will still prefer to work with small
example inputs like those that might appear in documentation rather than very
large inputs, which are fundamentally too unwieldy for humans to substantially
inspect. Of course, once a function is complete, Theorems
3.11-3.13 imply that the programmer can pass in much larger inputs without
  incurring run-time overhead.

That said, we certainly agree that when the programmer does happen to
produce an incomplete result containing a large number of hole closures or large
indeterminate forms, there arise interesting scalability challenges related both
to the UI and, for _very_ large results, run-time cost and memory usage. 

There is a brief discussion of some of the UI scalability challenges on p25
(lines 1184-1191), but this appears perhaps confusingly under the "Structure
Editors" heading. In the final paper, we will break out and expand on
this discussion of Scalability Challenges under its own heading. This discussion
will mention the topic of optimizing the run-time representation of hole
closures and indeterminate forms as an interesting avenue for future work. The
formalism in this paper can serve as the baseline correctness specification for
this sort of performance optimization research.

# Review B

The proof of Theorem 4.2 (see supplement) does not actually require formalizing
the idea that "evaluation order does not matter" -- this point was perhaps not
clear from the text on p21, so we will be sure to clarify this.

TODO: other stuff from Review B

# Review C

> When, if even, does type checking of the initial program fail?

In Hazel(nut) the Sensibility invariant (Prop. 3.14) implies that typechecking
never fails.

TODO: what about in Haskell etc.?

> Term expansion and type checking from the theory seem slow

The Sensibility invariant also implies that the program is not typechecked anew
on each edit. Instead, the edit actions themselves enforce well-typedness as
a structural invariant (by inserting holes as necessary). 

The expander is a simple single-pass function over the syntax tree, so in
programs with any non-trivial control flow, the cost of evaluation will far
exceed the cost of expansion. Expansion is compositional so for edits that
amount to hole filling (which would then be subject to the fill-and-resume
operation), only the expansion of the hole filling needs to be computed anew. We
will include these points in the new Scalability Challenges discussion section
mentioned in the response to Review A above.

> a user study seems to be needed to evaluate the claim made in this paper that
> Hazelnut Live aids program development

Lines 1180-1183 state that "we make no empirical claims regarding the usability
of the particular user interface presented in this paper. The Hazel user
interface as presented is a proof of concept [...]" 

This disclaimer is again confusingly buried under the Structure Editors heading
at the end of the paper. In the final paper, we will more clearly state in the
introduction that a comprehensive treatment of the question of how best to
present the additional information (hole closures, indeterminate forms) that our
semantics generates to human programmers remains an open question. The UI in Sec 
2 is meant only to demonstrate one possible design. We anticipate that there
will be many possible designs rooted in the theory developed in this paper, as
suggested in the conclusion of the paper. We do plan to conduct user studies in
the future as Hazel is slowly integrated into the classroom, but this is, as
Review B suggests, part of a longer term vision and beyond the scope of this
paper.

# Review D TODO: stuff from review D

