Thank you for your thoughtful feedback!

# A 

We expect that even while writing functions much larger 
than `qsort`, programmers will prefer small example inputs
(like those in documentation) because large inputs are
difficult for humans to meaningfully inspect. Once complete,
Theorems
3.11-3.13 imply that larger inputs require no overhead.

We agree that when an indeterminate result is large or contains many hole closures,
scalability challenges could arise. In the final paper, we will combine the discussion of UI scalability challenges (L1184) with discussion of future
work on optimization of hole closures and
indeterminate forms into a separate Scalability Challenges subsection.

# B

We will clarify that the proof of Theorem 4.2 does not require formalizing the notion that
"evaluation order does not matter", which is why we left discussion to the
supplement. 

Siek and Taha (2006) defined two application rules. Matching consolidates these.

By "essentially standard...", we mean that Complete Progress coincides with 
Progress for STLC (no mention of boxedval or indet).

Per Line 884-887, X is complete when there are no holes or
failed casts in X. Complete expressions cannot be indeterminate.

# C

> When, if even, does type checking of the initial program fail?

In Hazel(nut), Sensibility (Proposition 3.14) implies that typechecking
never fails.

> Term expansion and type checking from the theory seem slow

Sensibility also implies that typechecking need not occur per edit -- edit actions insert holes as necessary.

The expander is a single pass over the expression, so in
programs with any non-trivial control flow, the cost of evaluation dominates.

> a user study seems to be needed to evaluate the claim made in this paper that
> Hazelnut Live aids program development

Our claim in this paper is that substantially more information about run-time
behavior can be made available when the program is incomplete by
combining concepts from the Hazelnut calculus, gradual type theory and CMTT. How to best present this information to human programmers is an open question
worthy of additional human factors research. Lines 1180-1183 state
that "we make no empirical claims regarding the usability of the particular user
interface presented in this paper. The Hazel user interface as presented is
a proof of concept [...]". We will make this clearer in the final introduction. 
We do plan to conduct user studies in classrooms as Hazel develops, but
this is, as B suggests, part of a longer term research vision. We hope that there will be many
other designs rooted in the semantics developed by this paper, as suggested
in the conclusion.




# Review D TODO: stuff from review D


---

TODO: answer these below the 500 word fold? 

# Review A



# Review B 

> In several places starting on page 15: "disequal"? Do you mean "unequal"? Or
> do you mean something else? If the latter, then please define what is meant.

TODO

> Is there a reason you do not state Finality as "If d final then there exists
> no d' such that d |-> d'"?

TODO

> Why does evaluation not stop if a cast fails. Shouldn't evaluation await the
> programmer in this case?

TODO

> The conclusion of Theorem 3.12 should be that "either there exists a d' such
> that d |-> d' or d val".

TODO

> more editor states are meaningful? More that what?

TODO


