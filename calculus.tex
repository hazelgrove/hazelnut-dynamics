% !TEX root = hazelnut-dynamics.tex

\clearpage
\newcommand{\calculusSec}{Hazelnut Live, Formally}
\section{\protect\calculusSec}
\label{sec:calculus}

We will now make the intuitions developed in the previous section formally precise by specifying the \HazelnutLive core calculus and  its accompanying metatheory. We have mechanized these formal developments using the Agda proof assistant \cite{norell:thesis,norell2009dependently}. Sec.~\ref{sec:agda-mechanization} provides some additional details on this mechanization and the supplemental material includes the full mechanization. % The proofs of the metatheorems are established by this mechanization; the proofs are only very briefly outlined in this section.

The syntax of the core calculus, specified in Fig.~\ref{fig:hazelnut-live-syntax}, consists of types and expressions with holes, which we refer to as H-types and H-expressions, respectively. We distinguish between \emph{external} H-expressions, $e$, and \emph{internal} H-expressions, $d$. External H-expressions correspond to programs as entered by the programmer (see Sec.~\ref{sec:implementation}\todo{or maybe Sec. 2?}{} for examples of manual, semi-automated and fully automated hole entry methods). Each well-typed external H-expression (as specified in Sec.~\ref{sec:external-statics}) expands to a well-typed internal H-expression (Sec.~\ref{sec:expansion}) before it is evaluated (Sec.~\ref{sec:evaluation}). We distinguish the external and internal languages because (1) the external language supports type inference and explicit type ascriptions, $\hexp : \htau$, but it is  formally simpler to eliminate ascriptions and specify a type assignment system when defining the dynamic semantics\todo{cite frank's notes}; and (2) we need additional syntactic machinery during evaluation for tracking hole closures and dynamic type casts. This machinery is initialized by the expansion step, rather than entered explicitly by the programmer. In this regard, the internal language is analagous to the cast calculus in the gradually typed lambda calculus \cite{DBLP:conf/snapl/SiekVCB15,Siek06a}, though as we will see the \HazelnutLive internal language goes beyond the cast calculus in several respects.

\input{fig-syntax}

% \rkc{this syntactic sugar is used in four places: ITCastSucceed, ITCastFail,
% ITGround, and ITExpand. that's not many, and those rules don't look much more
% cluttered without the sugar, so consider eliminating it. if so, just toggle the
% definition of the dcastthree macro to the unsugared option.}

\subsection{Static Semantics of the External Language}
\label{sec:external-statics}

\input{fig-bidirectional-typing}
\input{fig-type-consistency}

Let us start with a brief overview of the static semantics of the \HazelnutLive external language. H-types, $\htau$, classify external H-expressions, $e$, according to the type system in Fig. \ref{fig:bidirectional-typing}, which closely follows the \Hazelnut type system \cite{popl-paper} (the minor differences are discussed as they come up). The type system is specified in the \emph{bidirectional} style \cite{Pierce:2000ve,bidi-tutorial,DBLP:conf/icfp/DunfieldK13,Chlipala:2005da} around two mutually defined judgements. The type synthesis judgement, $\hsyn{\hGamma}{\hexp}{\htau}$, synthesizes a type $\htau$ for $\hexp$ assuming $\hGamma$, which tracks typing assumptions of the form $x : \htau$ in the usual manner. The type analysis judgement, $\hana{\hGamma}{\hexp}{\htau}$, instead checks $\hexp$ against a given $\htau$. Algorithmically, the type is an input of type analysis.% Algorithmically, the type is an output of type synthesis but an input of type analysis.

The benefit of specifying the \HazelnutLive external language bidirectionally, rather than as a type assignment system, is that the programmer does not need to annotate each hole with a type. Empty holes are written $\hehole{u}$, where $u$ is a hole name assumed unique (hole names are new to \HazelnutLive). Rule {SEHole}\todo{rule name macros}{} specifies that empty holes synthesize hole type, written $\tehole$. If an empty hole appears where an expression of some other type is expected, e.g. under an explicit ascription $e : \htau$ (governed by Rule {SAsc}) or in the argument position of a function application (governed by Rule {SAp}, discussed below), we apply the \emph{subsumption rule}, Rule {ASubsume}, which specifies that if an expression $e$ synthesizes type $\htau$, then it can be checked against any \emph{consistent} type, $\htau'$. Fig.~\ref{fig:tconsistent} specifies the type consistency relation, written $\tconsistent{\htau}{\htau'}$, which coincides with the type consistency relation from gradual type theory by identifying the hole type with the unknown type~\cite{Siek06a}. Two types are consistent if they differ only up to type holes in corresponding positions. Note that type consistency is reflexive and symmetric but it is not transitive (quite unlike subtyping, which is anti-symmetric and transitive, though subtyping can be integrated into a gradual type system following \citet{Siek:2007qy}). The hole type is consistent with every type, and so, by the subsumption rule, empty expression holes can appear where an expression of any type is expected.

Non-empty expression holes, written $\hhole{\hexp}{u}$, behave similarly. Rule {SNEHole} specifies that non-empty expression holes also synthesize hole type as long as the expression inside the hole, $\hexp$, synthesizes some (arbitrary) type. Non-empty expression holes therefore internalize the ``red squiggles'' that many editors display under or around type inconsistencies in a program.\todo{example?}

For the familiar forms of the lambda calculus, the rules again follow the prior work. For simplicity, the core calculus includes only a single base type, $b$, with a single constant, $c$, governed by Rule {SConst} (i.e. $b$ is the unit type). \Hazelnut instead defined a number type with a single operation, which we include in Appendix~\ref{sec:extensions} alongside various other standard extensions to the core calculus\todo{do this, say more?}. 

Rule {SVar} specifies that variables synthesize the corresponding type from $\hGamma$. 

For the sake of exposition, \HazelnutLive includes ``half-annotated'' lambdas, $\halam{x}{\htau}{\hexp}$, in addition to the unannotated lambdas, $\hlam{x}{\hexp}$, from \Hazelnut.  Half-annotated lambdas can appear in synthetic position (where an expected type is not known, e.g. at the top-level) according to Rule {SLam}, which is standard \cite{Chlipala:2005da}. Unannotated lambdas can only appear where the expected type is known to be either an arrow type or the hole type, which is treated as if it were the type $\tarr{\tehole}{\tehole}$. To avoid the need for two separate rules, the auxiliary relation $\arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}$ in Fig.~\ref{fig:arrmatch} produces the matched arrow type $\tarr{\tehole}{\tehole}$ given the hole type, and operates as the identity on arrow types \cite{DBLP:conf/snapl/SiekVCB15,DBLP:conf/popl/GarciaC15}. This allows us to specify a single rule, Rule {ALam}, governing unannotated lambdas. Note that a system supporting ML-style type reconstruction \cite{damas1982principal} might also define a synthetic rule governing unannotated lambdas, e.g. as outlined by \citet{DBLP:conf/icfp/DunfieldK13}. 

The matched arrow type judgement also appears in the rule governing function application, Rule {SAp}, which treats expressions in function position of hole type as if they were of type $\tarr{\tehole}{\tehole}$. 

\subsection{Expansion}
\label{sec:expansion}

\input{fig-expansion}
\input{fig-typing-dexp}

A hole context, $\hDelta$, is a list of bindings $\Dbinding{u}{\hGamma}{\htau}$.

\begin{theorem}[Expandability] ~
  \begin{enumerate}
    \item
      If $\hsyn{\hGamma}{\hexp}{\htau}$
      then $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$
      for some $\dexp$ and $\Delta$.
    \item
      If $\hana{\hGamma}{\hexp}{\htau}$
      then $\expandAna{\hGamma}{\hexp}{\htau}{\dexp}{\htau'}{\Delta}$
      for some $\dexp$ and $\htau'$ and $\Delta$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[Correspondence] ~
  \begin{enumerate}
    \item
      If $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$
      then $\hsyn{\hGamma}{\hexp}{\htau}$.
    \item
      If $\expandAna{\hGamma}{\hexp}{\htau}{\dexp}{\htau'}{\Delta}$
      then $\hana{\hGamma}{\hexp}{\htau}$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[Typed Expansion] ~
  \begin{enumerate}
    \item
      If $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$
      then $\hasType{\Delta}{\hGamma}{\dexp}{\htau}$.
    \item
      If $\expandAna{\hGamma}{\hexp}{\htau}{\dexp}{\htau'}{\Delta}$
      then $\tconsistent{\htau}{\htau'}$ and $\hasType{\Delta}{\hGamma}{\dexp}{\htau'}$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[Expansion Unicity] ~
  \begin{enumerate}
    \item
      If $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$
      and $\expandSyn{\hGamma}{\hexp}{\htau'}{\dexp'}{\Delta'}$
      then $\htau=\htau'$ and $\dexp=\dexp'$ and $\Delta=\Delta'$.
    \item
      If $\expandAna{\hGamma}{\hexp}{\htau_1}{\dexp}{\htau_2}{\Delta}$
      and $\expandAna{\hGamma}{\hexp}{\htau_1}{\dexp'}{\htau_2'}{\Delta'}$
      then $\dexp=\dexp'$ and $\htau_2=\htau_2'$ and $\Delta=\Delta'$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[Type Assignment Unicity]
  If $\hasType{\Delta}{\hGamma}{\dexp}{\htau}$
  and $\hasType{\Delta}{\hGamma}{\dexp}{\htau'}$
  then $\htau=\htau'$.
\end{theorem}



\subsection{Dynamic Semantics}
\label{sec:evaluation}

\input{fig-dynamics-aux}
%% \input{fig-dynamics-steps}
\input{fig-dynamics-contexts}

{\color{gray}\blindtext}
{\color{gray}\blindtext}
{\color{gray}\blindtext}
{\color{gray}\blindtext}
{\color{gray}\blindtext}

\begin{lemma}[Focus Formation] ~
  If $\selectEvalCtx{\dexp}{\evalctx}{\dexp'}$
  then $\isevalctx{\evalctx}$.
\end{lemma}

\begin{lemma}[Matched Ground Type Invariant] ~
  If $\groundmatch{\htau}{\htau'}$
  then $\isGround{\htau'}$
  and $\tconsistent{\htau}{\htau'}$
  and $\htau\neq\htau'$.
\end{lemma}

\begin{theorem}[Preservation]
  If $\hasType{\Delta}{\emptyset}{\dexp}{\htau}$ and
  $\stepsToD{\Delta}{\dexp}{\dexp'}$ then
  $\hasType{\Delta}{\emptyset}{\dexp'}{\htau}$.
\end{theorem}

\begin{theorem}[Progress]
  If $\hasType{\Delta}{\emptyset}{\dexp}{\htau}$ then either
  (i) $\stepsToD{}{\dexp}{\dexp'}$ or
  (ii) $\isIndet{\dexp}$ or
  (iii) $\isBoxedValue{\dexp}$.
\end{theorem}

\begin{theorem}[Canonical Value Forms]
  If $\hasType{\hDelta}{\emptyset}{\dexp}{\htau}$ and $\isValue{\dexp}$
  then $\htau\neq\tehole$ and
  \begin{enumerate}[label=(\alph*)]
    \item If $\htau=b$ then $\dexp=c$.
    \item If $\htau=\tarr{\htau_1}{\htau_2}$
          then $\dexp=\halam{x}{\htau_1}{\dexp'}$
          where $\hasType{\hDelta}{x : \htau_1}{\dexp'}{\htau_2}$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[Canonical Boxed Forms]
  If $\hasType{\hDelta}{\emptyset}{\dexp}{\htau}$ and $\isBoxedValue{\dexp}$
  then
  \begin{enumerate}[label=(\alph*)]
    \item If $\htau=b$ then $\dexp=c$.
    \item If $\htau=\tarr{\htau_1}{\htau_2}$ then either
      \begin{enumerate}
        \item[i.]
          $\dexp=\halam{x}{\htau_1}{\dexp'}$
          where $\hasType{\hDelta}{x : \htau_1}{\dexp'}{\htau_2}$, or
        \item[ii.]
          $\dexp=\dcasttwo{\dexp'}{\tarr{\htau_1'}{\htau_2'}}{\tarr{\htau_1}{\htau_2}}$
          where $\tarr{\htau_1'}{\htau_2'}\neq\tarr{\htau_1}{\htau_2}$
          and $\hasType{\hDelta}{\emptyset}{\dexp'}{\tarr{\htau_1'}{\htau_2'}}$.
      \end{enumerate}
    \item If $\htau=\tehole$
          then $\dexp=\dcasttwo{\dexp'}{\htau'}{\tehole}$
          where $\isGround{\htau'}$
          and $\hasType{\hDelta}{\emptyset}{\dexp'}{\htau'}$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[Canonical Indeterminate Forms]
  If $\hasType{\hDelta}{\emptyset}{\dexp}{\htau}$
  and $\isIndet{\dexp}$
  then either
  \begin{enumerate}[label=(\alph*)]
    \item
      $\dexp=\dehole{u}{\subst}{}$
      and $\Dbinding{u}{\Gamma'}{\htau}\in\hDelta$, or
    \item
      $\dexp=\dhole{\dexp'}{u}{\subst}{}$
      and $\isFinal{\dexp'}$
      and $\hasType{\hDelta}{\emptyset}{\dexp'}{\htau'}$
      and $\Dbinding{u}{\Gamma'}{\htau}\in\hDelta$, or
    \item
      $\dexp=\dap{\dexp_1}{\dexp_2}$
      and $\hasType{\hDelta}{\emptyset}{\dexp_1}{\tarr{\htau_2}{\htau}}$
      and $\hasType{\hDelta}{\emptyset}{\dexp_2}{\htau_2}$
      and $\isIndet{\dexp_1}$
      and $\isFinal{\dexp_2}$
      and $\dexp_1\neq\dcasttwo{\dexp_1}{\tarr{\htau_3}{\htau_4}}
                                        {\tarr{\htau_3'}{\htau_4'}}$, or
    %% \item
    %%   \begin{enumerate}
    %%     \item blah
    %%     \item blah
    %%     \item blah
    %%   \end{enumerate}
    \item
      $\htau=b$
      and $\dexp=\dcasttwo{\dexp'}{\tehole}{b}$
      and $\isIndet{\dexp'}$
      and $\dexp'\neq\dcasttwo{\dexp''}{\htau'}{\tehole}$, or
    \item
      $\htau=b$
      and $\dexp=\dcastfail{\dexp'}{\htau'}{b}$
      and $\isGround{\htau'}$
      and $\htau'\neq{b}$
      and $\hasType{\hDelta}{\emptyset}{\dexp'}{\htau'}$, or
    \item
      $\htau=\tarr{\htau_{11}}{\htau_{12}}$
      and $\dexp=\dcasttwo{\dexp'}{\tarr{\htau_1}{\htau_2}}
                                  {\tarr{\htau_{11}}{\htau_{12}}}$
      and $\isIndet{\dexp'}$
      and $\tarr{\htau_1}{\htau_2}\neq\tarr{\htau_{11}}{\htau_{12}}$, or
    \item
      $\htau=\tarr{\tehole}{\tehole}$
      %% $\htau=\tarr{\htau_{11}}{\htau_{12}}$
      %% and $\htau_{11}=\tehole$
      %% and $\htau_{12}=\tehole$
      and $\dexp=\dcastthree{\dexp'}{\tehole}{\tehole}{\tehole}$
      and $\isIndet{\dexp'}$
      and $\dexp'\neq\dcasttwo{\dexp''}{\htau'}{\tehole}$, or
    \item
      $\htau=\tarr{\tehole}{\tehole}$
      %% $\htau=\tarr{\htau_{11}}{\htau_{12}}$
      %% and $\htau_{11}=\tehole$
      %% and $\htau_{12}=\tehole$
      and $\dexp=\dcastfail{\dexp'}{\htau'}{\tarr{\tehole}{\tehole}}$
      %% and $\dexp=\dcastfail{\dexp'}{\htau'}{\tarr{\htau_{11}}{\htau_{12}}}$
      and $\htau'\neq\htau$
      and $\isGround{\htau'}$
      and $\isIndet{\dexp'}$
      and $\hasType{\hDelta}{\emptyset}{\dexp'}{\htau'}$, or
    \item
      $\htau=\tehole$
      and $\dexp=\dcasttwo{\dexp'}{\htau'}{\tehole}$
      and $\isGround{\htau'}$
      and $\isIndet{\dexp'}$.
  \end{enumerate}
\end{theorem}

\autoref{fig:complete} defines \emph{complete} H-types, H-expressions, and
dynamic H-expressions to be those terms without type or expression holes.

\begin{theorem}[Complete Progress]
  If $\hasType{\hDelta}{\emptyset}{\dexp}{\htau}$
  and $\isComplete{\dexp}$
  then either $\stepsToD{}{\dexp}{\dexp'}$
  or $\isValue{\dexp}$.
\end{theorem}

\begin{theorem}[Complete Preservation]
  If $\hasType{\hDelta}{\emptyset}{\dexp}{\htau}$
  and $\isComplete{\dexp}$
  and $\stepsToD{}{\dexp}{\dexp'}$
  then $\hasType{\hDelta}{\emptyset}{\dexp'}{\htau}$.
\end{theorem}

\begin{theorem}[Complete Expansion] ~
  \begin{enumerate}
    \item
      If $\isComplete{\hexp}$
      and $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$
      then $\isComplete{\dexp}$.
    \item
      If $\isComplete{\hexp}$
      and $\expandAna{\hGamma}{\hexp}{\htau}{\dexp}{\htau'}{\Delta}$
      then $\isComplete{\dexp}$.
  \end{enumerate}
\end{theorem}




\cy{definition of complete types and terms? do we care about completeness
  of $\hexp$s or $\dexp$s?}


%% \begin{figure}[!ht]
%%   \begin{definition}
%%     $\hasType{\Delta}{\hGamma}{\sigma}{\hGamma'}$ iff for each $\dexp/x \in \sigma$, we have $x : \htau \in \hGamma'$ and $\hasType{\Delta}{\hGamma}{\dexp}{\htau}$.
%%   \end{definition}
%%   \caption{substitution type assignment}
%%   \label{fig:subassign}
%% \end{figure}


%% \begin{figure}[!ht]
  \begin{definition}[Substitution Typing]
    $\hasType{\Delta}{\hGamma}{\sigma}{\hGamma'}$ iff $\domof{\sigma} = \domof{\Gamma'}$ and for each $\dexp/x \in \sigma$, we have $x : \htau \in \hGamma'$ and $\hasType{\Delta}{\hGamma}{\dexp}{\htau}$.
  \end{definition}
%%   \caption{substitution type assignment}
%% \end{figure}


\subsection{Agda Mechanization}
\label{sec:agda-mechanization}



%%   \halam{x}{\htau}{\evalctx} ~\vert~

{\color{gray}\blindtext}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Metatheory: Correctness of Edit-and-Resume}
\label{sec:resumption}

\input{fig-substitution}
\input{fig-multi-step}

{\color{gray}\blindtext}

\rkc{some of these statements may need additional typing premises}

\begin{theorem}[Instantiation]
  If $\hasType{\hDelta}{\hGamma}{\dexp}{\tau}$
  and $\Dbinding{u}{\hGamma'}{\htau'}\in\hDelta$
  and $\hasType{\hDelta}{\hGamma'}{\dexp'}{\htau'}$
  then $\hasType{\hDelta}{\hGamma}{\instantiate{\dexp'}{u}{\dexp}}{\tau}$.
\end{theorem}

\autoref{fig:multi-step} defines the multi-step relation as the reflexive,
transitive closure of the single-step relation.

\begin{lemma}[Finality]
  If $\isFinal{\dexp}$ and $\multiStepsTo{\dexp}{\dexp'}$
  then $\dexp=\dexp'$.
\end{lemma}

\begin{theorem}[Commutativity]
  If $\multiStepsTo{\dexp_0}{\dexp_1}$
  then $\multiStepsTo{\instantiate{\dexp}{u}{\dexp_0}}
                     {\instantiate{\dexp}{u}{\dexp_1}}$.
\end{theorem}

\begin{theorem}[Confluence]
  If $\multiStepsTo{\dexp}{\dexp_1}$
  and $\multiStepsTo{\dexp}{\dexp_2}$
  then there exists $\dexp'$ such that
  $\multiStepsTo{\dexp_1}{\dexp'}$ and
  $\multiStepsTo{\dexp_2}{\dexp'}$.
\end{theorem}

\begin{corollary}[Final Confluence]
  If $\multiStepsTo{\dexp}{\dexp_1}$
  and $\isFinal{\dexp_1}$
  and $\multiStepsTo{\dexp}{\dexp_2}$
  then $\multiStepsTo{\dexp_2}{\dexp_1}$.
  \begin{proof}
    By Confluence and Finality.
  \end{proof}
\end{corollary}

\begin{theorem}[Resumption]
  If $\multiStepsTo{\dexp_1}{\dexp_2}$
  and $\isFinal{\dexp_2}$
  and $\multiStepsTo{\instantiate{\dexp_3}{u}{\dexp_1}}{\dexp_4}$
  and $\isFinal{\dexp_4}$
  then $\multiStepsTo{\instantiate{\dexp_3}{u}{\dexp_2}}{\dexp_4}$.
  \begin{proof}
    By Commutativity,
    $\multiStepsTo{\instantiate{\dexp_3}{u}{\dexp_1}}
                  {\instantiate{\dexp_3}{u}{\dexp_2}}$.
    By Final Confluence, we can conclude.
  \end{proof}
\end{theorem}

Talk about weak vs strong conversion vs sharing -- see \url{http://gallium.inria.fr/~maranget/papers/jwk60.pdf} and cited work in the intro. See also \url{https://www.lri.fr/~blsk/Docs/Balabonski-FullLaziness-POPL12.pdf}?? Original Church-Rosser paper -- \url{http://www.ams.org/journals/tran/1936-039-03/S0002-9947-1936-1501858-0/S0002-9947-1936-1501858-0.pdf}.


\begin{comment}

\begin{theorem}[Maximum Informativity]
If the expansion produces $t1$, and there exists another possible type choice
$t2$, then $t1 \sim t2$ and $t1 JOIN t2 = t1$
\end{theorem}\footnote{idea is that special casing the holes in EANEHole gives you ``the
most descriptive hole types'' for some sense of what that means -- they'd
all just be hole other wise. from Matt:
\begin{quote}
It sounds like we need a something akin to an abstract domain (a lattice),
where hole has the least information, and a fully-defined type (without
holes) has the most information.  You can imagine that this lattice really
expands the existing definition we have of type consistency, which is
merely the predicate that says whether two types are comparable
(“join-able”) in this lattice.  lattice join is the operation that goes
through the structure of two (consistent) types, and chooses the structure
that is more defined (i.e., non-hole, if given the choice between hole and
non-hole).

The rule choosenonhole below is the expansion of this consistency rule that
we already have (hole consistent with everything)
\end{quote}}

\begin{verbatim}
t not hole
-------------------- :: choose-non-hole
hole JOIN t  = t
\end{verbatim}
\begin{verbatim}
------------ :: hole-consistent-with-everything
hole ~ t
\end{verbatim}

\end{comment}
