% !TEX root = hazelnut-dynamics.tex

\clearpage
\newcommand{\calculusSec}{Hazelnut Live, Formally}
\section{\protect\calculusSec}
\label{sec:calculus}

We will now make the intuitions developed in the previous section formally precise by specifying the \HazelnutLive core calculus and  its accompanying metatheory. We have mechanized these formal developments using the Agda proof assistant \cite{norell:thesis,norell2009dependently}. Sec.~\ref{sec:agda-mechanization} provides some additional details on this mechanization and the supplemental material includes the full mechanization. % The proofs of the metatheorems are established by this mechanization; the proofs are only very briefly outlined in this section.

The syntax of the core calculus, specified in Fig.~\ref{fig:hazelnut-live-syntax}, consists of types and expressions with holes. We distinguish between \emph{external} expressions, $e$, and \emph{internal} expressions, $d$. External expressions correspond to programs as entered by the programmer (see Sec.~\ref{sec:implementation}\todo{or maybe Sec. 2?}{} for discussion of manual, semi-automated and fully automated hole entry methods). Each well-typed external expression (as specified in Sec.~\ref{sec:external-statics} below) expands to a well-typed internal expression (Sec.~\ref{sec:expansion}) before it is evaluated (Sec.~\ref{sec:evaluation}). We distinguish the external and internal languages because (1) the external language supports type inference and explicit type ascriptions, $\hexp : \htau$, but it is  formally simpler to eliminate ascriptions and specify a type assignment system when defining the dynamic semantics\todo{cite frank's notes}; and (2) we need additional syntactic machinery during evaluation for tracking hole closures and dynamic type casts. This machinery is inserted by the expansion step, rather than entered explicitly by the programmer. In this regard, the internal language is analagous to the cast calculus in the gradually typed lambda calculus \cite{DBLP:conf/snapl/SiekVCB15,Siek06a}, though as we will see the \HazelnutLive internal language goes beyond the cast calculus in several respects.

\input{fig-syntax}

% \rkc{this syntactic sugar is used in four places: ITCastSucceed, ITCastFail,
% ITGround, and ITExpand. that's not many, and those rules don't look much more
% cluttered without the sugar, so consider eliminating it. if so, just toggle the
% definition of the dcastthree macro to the unsugared option.}

\subsection{Static Semantics of the External Language}
\label{sec:external-statics}

\input{fig-bidirectional-typing}
\input{fig-type-consistency}

Let us start with a brief overview of the static semantics of the \HazelnutLive external language. Types, $\htau$, classify external expressions, $e$, according to the type system in Fig. \ref{fig:bidirectional-typing}, which closely follows the \Hazelnut type system \cite{popl-paper} (the minor differences are discussed as they come up). The type system is specified in the \emph{bidirectional} style \cite{Pierce:2000ve,bidi-tutorial,DBLP:conf/icfp/DunfieldK13,Chlipala:2005da} around two mutually defined judgements. The type synthesis judgement, $\hsyn{\hGamma}{\hexp}{\htau}$, synthesizes a type $\htau$ for $\hexp$ assuming $\hGamma$, which tracks typing assumptions of the form $x : \htau$ in the usual manner \cite{pfpl,tapl}. The type analysis judgement, $\hana{\hGamma}{\hexp}{\htau}$, instead checks $\hexp$ against a given $\htau$. Algorithmically, the type is an input of type analysis.% Algorithmically, the type is an output of type synthesis but an input of type analysis.

The benefit of specifying the \HazelnutLive external language bidirectionally is that the programmer does not need to annotate each hole with a type. Empty holes are written $\hehole{u}$, where $u$ is a hole name assumed unique (this notation is taken from \Hazelnut; hole names are new to \HazelnutLive). Rule {SEHole}\todo{rule name macros}{} specifies that empty holes synthesize hole type, written $\tehole$. If an empty hole appears where an expression of some other type is expected, e.g. under an explicit ascription $e : \htau$ (governed by Rule {SAsc}) or in the argument position of a function application (governed by Rule {SAp}, discussed below), we apply the \emph{subsumption rule}, Rule {ASubsume}, which specifies that if an expression $e$ synthesizes type $\htau$, then it can be checked against any \emph{consistent} type, $\htau'$. Fig.~\ref{fig:tconsistent} specifies the type consistency relation, written $\tconsistent{\htau}{\htau'}$, which coincides with the type consistency relation from gradual type theory by identifying the hole type with the unknown type~\cite{Siek06a}. Two types are consistent if they differ only up to type holes in corresponding positions. Note that type consistency is reflexive and symmetric but it is not transitive (quite unlike subtyping, which is anti-symmetric and transitive; subtyping can be integrated into a gradual type system following \citet{Siek:2007qy}). The hole type is consistent with every type, and so, by the subsumption rule, empty expression holes can appear where an expression of any type is expected.

Non-empty expression holes, written $\hhole{\hexp}{u}$, behave similarly. Rule {SNEHole} specifies that non-empty expression holes also synthesize hole type as long as the expression inside the hole, $\hexp$, synthesizes some (arbitrary) type. Non-empty expression holes therefore internalize the ``red squiggles'' that many editors display under or around type inconsistencies in a program.\todo{example?}

For the familiar forms of the lambda calculus, the rules again follow prior work. For simplicity, the core calculus includes only a single base type, $b$, with a single constant, $c$, governed by Rule {SConst} (i.e. $b$ is the unit type). \Hazelnut instead defined a number type with a single operation, which we include in Appendix~\ref{sec:extensions} alongside various other standard extensions to the core calculus\todo{do this, say more?}. 

Rule {SVar} specifies that variables synthesize the corresponding type from $\hGamma$. 

For the sake of exposition, \HazelnutLive includes ``half-annotated'' lambdas, $\halam{x}{\htau}{\hexp}$, in addition to the unannotated lambdas, $\hlam{x}{\hexp}$, from \Hazelnut.  Half-annotated lambdas can appear in synthetic position  according to Rule {SLam}, which is standard \cite{Chlipala:2005da}. Unannotated lambdas can only appear where the expected type is known to be either an arrow type or the hole type, which is treated as if it were $\tarr{\tehole}{\tehole}$. To avoid the need for two separate rules, Rule {ALam} uses the auxiliary relation $\arrmatch{\htau}{\tarr{\htau_1}{\htau_2}}$ in Fig.~\ref{fig:arrmatch}, which produces the matched arrow type $\tarr{\tehole}{\tehole}$ given the hole type, and operates as the identity on arrow types \cite{DBLP:conf/snapl/SiekVCB15,DBLP:conf/popl/GarciaC15}. Note that a system supporting ML-style type reconstruction \cite{damas1982principal} might include a synthetic rule for unannotated lambdas, e.g. as outlined by \citet{DBLP:conf/icfp/DunfieldK13}. 

The rule governing function application, Rule {SAp}, similarly treats expressions of hole type in function position as if they were of type $\tarr{\tehole}{\tehole}$ using the matched arrow type judgement.

\subsection{Expansion}
\label{sec:expansion}

\input{fig-expansion}
\input{fig-typing-dexp}

Well-typed external expressions expand to well-typed internal expressions, $d$, for evaluation. The rules governing expansion are given in Fig.~\ref{fig:expansion} and the rules governing type assignment for internal expressions are given in Fig.~\ref{fig:hasType}. 

Expansion is specified, much like the type system for the external language, in the bidirectional style by two mutually defined judgements. The synthetic expansion judgement, $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$, synthesizes a type, $\htau$, from $\hexp$, and produces an expansion, $d$, and a hole context, $\hDelta$. We say more about hole contexts below. The analytic expansion judgement, $\expandAna{\hGamma}{\hexp}{\htau}{\dexp}{\htau'}{\Delta}$, checks $\hexp$ against $\htau$ and produces an expansion, $d$, of type $\htau'$, and a hole context, $\hDelta$. The governing theorem below establishes that the type $\htau'$ is necessarily consistent with $\htau$.
\begin{thm}[Typed Expansion]\label{thm:typed-expansion} ~
  \begin{enumerate}[nolistsep]
    \item
      If $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$
      then $\hasType{\Delta}{\hGamma}{\dexp}{\htau}$.
    \item
      If $\expandAna{\hGamma}{\hexp}{\htau}{\dexp}{\htau'}{\Delta}$
      then $\tconsistent{\htau}{\htau'}$ and $\hasType{\Delta}{\hGamma}{\dexp}{\htau'}$.
  \end{enumerate}
\end{thm}
\noindent
The reason analytic expansion produces an expansion of consistent type is because the subsumption rule, as previously discussed, allows us to check an external expression against any type consistent with the type the expression actually synthesizes, while every internal expression can be assigned at most one type, i.e. the following standard unicity property holds of the type assignment system: 
\begin{thm}[Type Assignment Unicity]
  If $\hasType{\Delta}{\hGamma}{\dexp}{\htau}$
  and $\hasType{\Delta}{\hGamma}{\dexp}{\htau'}$
  then $\htau=\htau'$.
\end{thm}
\noindent
Consequently, analytic expansion reports the type actually assigned to the expansion it produces. For example, we can derive that $\expandAna{\hGamma}{c}{\tehole}{c}{b}{\emptyset}$, where $\emptyset$ is the empty hole context.

Before describing the rules in detail, let us state a few other useful theorems. The following theorem establishes that an expansion exists for every well-typed external expression.
 \begin{thm}[Expandability] \label{thm:expandability}~
  \begin{enumerate}[nolistsep]
    \item
      If $\hsyn{\hGamma}{\hexp}{\htau}$
      then $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$
      for some $\dexp$ and $\Delta$.
    \item
      If $\hana{\hGamma}{\hexp}{\htau}$
      then $\expandAna{\hGamma}{\hexp}{\htau}{\dexp}{\htau'}{\Delta}$
      for some $\dexp$ and $\htau'$ and $\Delta$.
  \end{enumerate}
\end{thm}
\noindent
The following theorem establishes that when an expansion exists, it is unique.
\begin{thm}[Expansion Unicity] \label{thm:expansion-unicity}~
  \begin{enumerate}[nolistsep]
    \item
      If $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$
      and $\expandSyn{\hGamma}{\hexp}{\htau'}{\dexp'}{\Delta'}$
      then $\htau=\htau'$ and $\dexp=\dexp'$ and $\Delta=\Delta'$.
    \item
      If $\expandAna{\hGamma}{\hexp}{\htau_1}{\dexp}{\htau_2}{\Delta}$
      and $\expandAna{\hGamma}{\hexp}{\htau_1}{\dexp'}{\htau_2'}{\Delta'}$
      then $\dexp=\dexp'$ and $\htau_2=\htau_2'$ and $\Delta=\Delta'$.
  \end{enumerate}
\end{thm}
\noindent
The following theorem establishes that expansion generalizes external typing.\todo{rename correspondence to generality}
\begin{thm}[Expansion Generality] \label{thm:expansion-generality}~
  \begin{enumerate}[nolistsep]
    \item
      If $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$
      then $\hsyn{\hGamma}{\hexp}{\htau}$.
    \item
      If $\expandAna{\hGamma}{\hexp}{\htau}{\dexp}{\htau'}{\Delta}$
      then $\hana{\hGamma}{\hexp}{\htau}$.
  \end{enumerate}
\end{thm}

The rules governing expansion of constants, variables and lambda expressions --- Rules {ESConst}, {ESVar}, {ESLam} and {EALam} --- and the corresponding type assignment rules --- Rules {TAConst}, {TAVar} and {TALam} --- mirror the typing rules from Fig.~\ref{fig:bidirectional-typing} (so the corresponding cases of Theorem~\ref{thm:typed-expansion}, Theorem~\ref{thm:expandability} and Theorem~\ref{thm:expansion-generality} are straightforward). Note that in the internal language, all lambdas are half-annotated, again to support type assignment---Rule {EALam} inserts the annotation onto unannotated external lambdas based on the given type. The rules governing expansion of holes, function application and ascription are more interesting, so let us consider them in turn.

\subsubsection{Hole Expansion} Rules {ESEHole}, {ESNEHole}, {EAEHole} and {EANEHole} govern the expansion of empty and non-empty expression holes to \emph{hole closures}, $\dehole{u}{\sigma}{}$ and $\dhole{\dexp}{u}{\sigma}{}$, respectively. 

The hole name, $u$, on a hole closure identifies the external hole that the hole closure corresponds to. Note that while we assume each hole name to be unique in the external language, there can be multiple hole closures with the same name during evaluation due to substitution (though in the initial expansion, the uniqueness condition happens to hold because evaluation has yet to occur). For example, the result from Fig.~\ref{fig:grades-example} showed four closures for the hole named 1\todo{update with actual number (four?) and hole name later}. There, we numbered each hole closure for a given hole sequentially, \li{1:1}, \li{1:2} and so on, but this is strictly for the sake of presentation so we omit hole closure numbers from the core calculus.

The hole expansion rules are the only rules that introduce hypotheses, of the form $\Dbinding{u}{\hGamma}{\htau}$, into the hole context, $\Delta$. The purpose of the hole context is to record a typing context, $\Gamma$, and a type, $\tau$, for each hole name, $u$.\footnote{We use a hole context, rather than recording the typing context and type directly on each hole closure, to ensure that all closures for a hole name have the same typing context and type.} This notation for hole contexts is taken from contextual modal type theory (CMTT) \cite{Nanevski2008}, identifying hole names with metavariables and hole contexts with metavariable contexts (we say more about the connection with CMTT below). In all four hole expansion rules, the typing context recorded in the hole context is simply the current typing context when the hole is expanded. In the synthetic hole expansion rules, {ESEHole} and {ESNEHole}, the generated hole context assigns the hole type, $\tehole$, to $u$, as in the typing rules. However, the first two premises of the expansion subsumption rule, Rule EASubsume, disallow the use of subsumption for holes in analytic position during expansion. Instead, we have separate analytic rules, {EAEHole} and {EANEHole}, which record the type that the hole is being checked against into the hole context. This is again so that we can use a type assignment system for the internal language --- the type assignment rules TAEHole and TANEHole in Fig.~\ref{fig:hasType} assign the corresponding type from the hole context to the hole closure.

Each hole closure also has an associated environment, $\sigma$, which is a finite substitution of the form $[d_1/x_1, ~\cdots, d_n/x_n]$ for $n \geq 0$. The purpose of the closure environment is to keep a record of the substitutions that occur around the hole as evaluation occurs. Initially, no evaluation has occured, so the initial environment generated by the hole expansion rules is the identity substitution for the typing context associated with $u$ in $\Delta$, which we notate $\idof{\hGamma}$ and define as follows.
\begin{defn}[Identity Substitution] $\idof{x_1 : \tau_1, ~\cdots, x_n : \tau_n} = [x_1/x_1, ~\cdots, x_n/x_n]$
\end{defn}
\noindent
The type assignment rules for hole closures, Rules TAEHole and TANEHole, require that we be able to check the environment of each hole closure against the corresponding typing context, written $\hasType{\Delta}{\hGamma}{\sigma}{\hGamma'}$ and defined as follows:\todo{check that the definition in the Agda corresponds}
\begin{defn}[Substitution Typing]
$\hasType{\Delta}{\hGamma}{\sigma}{\hGamma'}$ iff $\domof{\sigma} = \domof{\hGamma'}$ and for each $x : \htau \in \hGamma'$ we have that $d/x \in \sigma$ and $\hasType{\Delta}{\hGamma}{d}{\tau}$.
\end{defn}
\noindent
It is easy to verify that the identity substitution satisfies this requirement, i.e. that $\hasType{\Delta}{\hGamma}{\idof{\hGamma}}{\hGamma}$. We will see how closure environments evolve during evaluation in Sec.~\ref{sec:evaluation}.

\subsubsection{Cast Insertion} 
Consider the following example: $\hap{(\halam{x}{\tehole}{\hap{x}{c}})}{c}$. The type synthesized for this example viewed as an external expression is $\tehole$, because the hole type annotation on $x$ allows us to apply it as a function of type $\tarr{\tehole}{\tehole}$ as previously discussed, and the outer argument, $c$, can be checked against type $\tehole$ by subsumption. However, viewed as an internal expression, this example is not well-typed---we do not have subsumption in the type assignment system defined in Fig.~\ref{fig:hasType}. Indeed, it would violate type safety if we could assign a type to this example in the internal language, because beta reduction of this example viewed as an internal expression would result in $c(c)$, which is not well-typed ($c$ does not have arrow type). The problem is that leaving the argument type unknown leaves how the argument is being used (in this case, as a function) also unknown.\footnote{In a system where type reconstruction is first used to try to fill in type holes, we could express a similar example by using $x$ at two or more different types, thereby causing type reconstruction to fail. Rather than arbitrarily choosing one of the possible types for $x$ and inserting non-empty holes around uses that are inconsistent with that choice, we could leave the type hole unfilled and rely on the cast insertion machinery described here. On the other hand, if it is acceptable to arbitrarily choose one of the possible types, and type reconstruction is complete, then type holes will never appear in the internal language and the cast insertion machinery described in this section can be omitted entirely, leaving only the hole closure machinery described previously.}\todo{this footnote should probably be integrated into and refer to Sec. 2?}{} Recall that we can interpret hole types as unknown types from gradual type theory. This provides us with the solution to this problem: cast insertion. 

\subsection{Dynamic Semantics}
\label{sec:evaluation}

\input{fig-dynamics-aux}
%% \input{fig-dynamics-steps}
\input{fig-dynamics-contexts}

{\color{gray}\blindtext}
{\color{gray}\blindtext}
{\color{gray}\blindtext}
{\color{gray}\blindtext}
{\color{gray}\blindtext}

\begin{lemma}[Focus Formation] ~
  If $\selectEvalCtx{\dexp}{\evalctx}{\dexp'}$
  then $\isevalctx{\evalctx}$.
\end{lemma}

\begin{lemma}[Matched Ground Type Invariant] ~
  If $\groundmatch{\htau}{\htau'}$
  then $\isGround{\htau'}$
  and $\tconsistent{\htau}{\htau'}$
  and $\htau\neq\htau'$.
\end{lemma}

\begin{theorem}[Preservation]
  If $\hasType{\Delta}{\emptyset}{\dexp}{\htau}$ and
  $\stepsToD{\Delta}{\dexp}{\dexp'}$ then
  $\hasType{\Delta}{\emptyset}{\dexp'}{\htau}$.
\end{theorem}

\begin{theorem}[Progress]
  If $\hasType{\Delta}{\emptyset}{\dexp}{\htau}$ then either
  (i) $\stepsToD{}{\dexp}{\dexp'}$ or
  (ii) $\isIndet{\dexp}$ or
  (iii) $\isBoxedValue{\dexp}$.
\end{theorem}

\begin{theorem}[Canonical Value Forms]
  If $\hasType{\hDelta}{\emptyset}{\dexp}{\htau}$ and $\isValue{\dexp}$
  then $\htau\neq\tehole$ and
  \begin{enumerate}[label=(\alph*)]
    \item If $\htau=b$ then $\dexp=c$.
    \item If $\htau=\tarr{\htau_1}{\htau_2}$
          then $\dexp=\halam{x}{\htau_1}{\dexp'}$
          where $\hasType{\hDelta}{x : \htau_1}{\dexp'}{\htau_2}$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[Canonical Boxed Forms]
  If $\hasType{\hDelta}{\emptyset}{\dexp}{\htau}$ and $\isBoxedValue{\dexp}$
  then
  \begin{enumerate}[label=(\alph*)]
    \item If $\htau=b$ then $\dexp=c$.
    \item If $\htau=\tarr{\htau_1}{\htau_2}$ then either
      \begin{enumerate}
        \item[i.]
          $\dexp=\halam{x}{\htau_1}{\dexp'}$
          where $\hasType{\hDelta}{x : \htau_1}{\dexp'}{\htau_2}$, or
        \item[ii.]
          $\dexp=\dcasttwo{\dexp'}{\tarr{\htau_1'}{\htau_2'}}{\tarr{\htau_1}{\htau_2}}$
          where $\tarr{\htau_1'}{\htau_2'}\neq\tarr{\htau_1}{\htau_2}$
          and $\hasType{\hDelta}{\emptyset}{\dexp'}{\tarr{\htau_1'}{\htau_2'}}$.
      \end{enumerate}
    \item If $\htau=\tehole$
          then $\dexp=\dcasttwo{\dexp'}{\htau'}{\tehole}$
          where $\isGround{\htau'}$
          and $\hasType{\hDelta}{\emptyset}{\dexp'}{\htau'}$.
  \end{enumerate}
\end{theorem}

\begin{theorem}[Canonical Indeterminate Forms]
  If $\hasType{\hDelta}{\emptyset}{\dexp}{\htau}$
  and $\isIndet{\dexp}$
  then either
  \begin{enumerate}[label=(\alph*)]
    \item
      $\dexp=\dehole{u}{\subst}{}$
      and $\Dbinding{u}{\Gamma'}{\htau}\in\hDelta$, or
    \item
      $\dexp=\dhole{\dexp'}{u}{\subst}{}$
      and $\isFinal{\dexp'}$
      and $\hasType{\hDelta}{\emptyset}{\dexp'}{\htau'}$
      and $\Dbinding{u}{\Gamma'}{\htau}\in\hDelta$, or
    \item
      $\dexp=\dap{\dexp_1}{\dexp_2}$
      and $\hasType{\hDelta}{\emptyset}{\dexp_1}{\tarr{\htau_2}{\htau}}$
      and $\hasType{\hDelta}{\emptyset}{\dexp_2}{\htau_2}$
      and $\isIndet{\dexp_1}$
      and $\isFinal{\dexp_2}$
      and $\dexp_1\neq\dcasttwo{\dexp_1}{\tarr{\htau_3}{\htau_4}}
                                        {\tarr{\htau_3'}{\htau_4'}}$, or
    %% \item
    %%   \begin{enumerate}
    %%     \item blah
    %%     \item blah
    %%     \item blah
    %%   \end{enumerate}
    \item
      $\htau=b$
      and $\dexp=\dcasttwo{\dexp'}{\tehole}{b}$
      and $\isIndet{\dexp'}$
      and $\dexp'\neq\dcasttwo{\dexp''}{\htau'}{\tehole}$, or
    \item
      $\htau=b$
      and $\dexp=\dcastfail{\dexp'}{\htau'}{b}$
      and $\isGround{\htau'}$
      and $\htau'\neq{b}$
      and $\hasType{\hDelta}{\emptyset}{\dexp'}{\htau'}$, or
    \item
      $\htau=\tarr{\htau_{11}}{\htau_{12}}$
      and $\dexp=\dcasttwo{\dexp'}{\tarr{\htau_1}{\htau_2}}
                                  {\tarr{\htau_{11}}{\htau_{12}}}$
      and $\isIndet{\dexp'}$
      and $\tarr{\htau_1}{\htau_2}\neq\tarr{\htau_{11}}{\htau_{12}}$, or
    \item
      $\htau=\tarr{\tehole}{\tehole}$
      %% $\htau=\tarr{\htau_{11}}{\htau_{12}}$
      %% and $\htau_{11}=\tehole$
      %% and $\htau_{12}=\tehole$
      and $\dexp=\dcastthree{\dexp'}{\tehole}{\tehole}{\tehole}$
      and $\isIndet{\dexp'}$
      and $\dexp'\neq\dcasttwo{\dexp''}{\htau'}{\tehole}$, or
    \item
      $\htau=\tarr{\tehole}{\tehole}$
      %% $\htau=\tarr{\htau_{11}}{\htau_{12}}$
      %% and $\htau_{11}=\tehole$
      %% and $\htau_{12}=\tehole$
      and $\dexp=\dcastfail{\dexp'}{\htau'}{\tarr{\tehole}{\tehole}}$
      %% and $\dexp=\dcastfail{\dexp'}{\htau'}{\tarr{\htau_{11}}{\htau_{12}}}$
      and $\htau'\neq\htau$
      and $\isGround{\htau'}$
      and $\isIndet{\dexp'}$
      and $\hasType{\hDelta}{\emptyset}{\dexp'}{\htau'}$, or
    \item
      $\htau=\tehole$
      and $\dexp=\dcasttwo{\dexp'}{\htau'}{\tehole}$
      and $\isGround{\htau'}$
      and $\isIndet{\dexp'}$.
  \end{enumerate}
\end{theorem}

\autoref{fig:complete} defines \emph{complete} types, expressions, and
dynamic expressions to be those terms without type or expression holes.

\begin{theorem}[Complete Progress]
  If $\hasType{\hDelta}{\emptyset}{\dexp}{\htau}$
  and $\isComplete{\dexp}$
  then either $\stepsToD{}{\dexp}{\dexp'}$
  or $\isValue{\dexp}$.
\end{theorem}

\begin{theorem}[Complete Preservation]
  If $\hasType{\hDelta}{\emptyset}{\dexp}{\htau}$
  and $\isComplete{\dexp}$
  and $\stepsToD{}{\dexp}{\dexp'}$
  then $\hasType{\hDelta}{\emptyset}{\dexp'}{\htau}$
  and $\isComplete{\dexp'}$.
\end{theorem}

\begin{theorem}[Complete Expansion] ~
  \begin{enumerate}
    \item
      If $\isComplete{\hexp}$
      and $\expandSyn{\hGamma}{\hexp}{\htau}{\dexp}{\Delta}$
      then $\isComplete{\dexp}$.
    \item
      If $\isComplete{\hexp}$
      and $\expandAna{\hGamma}{\hexp}{\htau}{\dexp}{\htau'}{\Delta}$
      then $\isComplete{\dexp}$.
  \end{enumerate}
\end{theorem}




\cy{definition of complete types and terms? do we care about completeness
  of $\hexp$s or $\dexp$s?}


%% \begin{figure}[!ht]
%%   \begin{definition}
%%     $\hasType{\Delta}{\hGamma}{\sigma}{\hGamma'}$ iff for each $\dexp/x \in \sigma$, we have $x : \htau \in \hGamma'$ and $\hasType{\Delta}{\hGamma}{\dexp}{\htau}$.
%%   \end{definition}
%%   \caption{substitution type assignment}
%%   \label{fig:subassign}
%% \end{figure}


%% \begin{figure}[!ht]
  \begin{definition}[Substitution Typing]
    $\hasType{\Delta}{\hGamma}{\sigma}{\hGamma'}$ iff $\domof{\sigma} = \domof{\Gamma'}$ and for each $\dexp/x \in \sigma$, we have $x : \htau \in \hGamma'$ and $\hasType{\Delta}{\hGamma}{\dexp}{\htau}$.
  \end{definition}
%%   \caption{substitution type assignment}
%% \end{figure}


\subsection{Agda Mechanization}
\label{sec:agda-mechanization}



%%   \halam{x}{\htau}{\evalctx} ~\vert~

{\color{gray}\blindtext}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Metatheory: Correctness of Edit-and-Resume}
\label{sec:resumption}

\input{fig-substitution}
\input{fig-multi-step}

{\color{gray}\blindtext}

\rkc{some of these statements may need additional typing premises}

\begin{theorem}[Instantiation]
  If $\hasType{\hDelta}{\hGamma}{\dexp}{\tau}$
  and $\Dbinding{u}{\hGamma'}{\htau'}\in\hDelta$
  and $\hasType{\hDelta}{\hGamma'}{\dexp'}{\htau'}$
  then $\hasType{\hDelta}{\hGamma}{\instantiate{\dexp'}{u}{\dexp}}{\tau}$.
\end{theorem}

\autoref{fig:multi-step} defines the multi-step relation as the reflexive,
transitive closure of the single-step relation.

\begin{lemma}[Finality]
  If $\isFinal{\dexp}$ and $\multiStepsTo{\dexp}{\dexp'}$
  then $\dexp=\dexp'$.
\end{lemma}

\begin{theorem}[Commutativity]
  If $\multiStepsTo{\dexp_0}{\dexp_1}$
  then $\multiStepsTo{\instantiate{\dexp}{u}{\dexp_0}}
                     {\instantiate{\dexp}{u}{\dexp_1}}$.
\end{theorem}

\begin{theorem}[Confluence]
  If $\multiStepsTo{\dexp}{\dexp_1}$
  and $\multiStepsTo{\dexp}{\dexp_2}$
  then there exists $\dexp'$ such that
  $\multiStepsTo{\dexp_1}{\dexp'}$ and
  $\multiStepsTo{\dexp_2}{\dexp'}$.
\end{theorem}

\begin{corollary}[Final Confluence]
  If $\multiStepsTo{\dexp}{\dexp_1}$
  and $\isFinal{\dexp_1}$
  and $\multiStepsTo{\dexp}{\dexp_2}$
  then $\multiStepsTo{\dexp_2}{\dexp_1}$.
  \begin{proof}
    By Confluence and Finality.
  \end{proof}
\end{corollary}

\begin{theorem}[Resumption]
  If $\multiStepsTo{\dexp_1}{\dexp_2}$
  and $\isFinal{\dexp_2}$
  and $\multiStepsTo{\instantiate{\dexp_3}{u}{\dexp_1}}{\dexp_4}$
  and $\isFinal{\dexp_4}$
  then $\multiStepsTo{\instantiate{\dexp_3}{u}{\dexp_2}}{\dexp_4}$.
  \begin{proof}
    By Commutativity,
    $\multiStepsTo{\instantiate{\dexp_3}{u}{\dexp_1}}
                  {\instantiate{\dexp_3}{u}{\dexp_2}}$.
    By Final Confluence, we can conclude.
  \end{proof}
\end{theorem}

Talk about weak vs strong conversion vs sharing -- see \url{http://gallium.inria.fr/~maranget/papers/jwk60.pdf} and cited work in the intro. See also \url{https://www.lri.fr/~blsk/Docs/Balabonski-FullLaziness-POPL12.pdf}?? Original Church-Rosser paper -- \url{http://www.ams.org/journals/tran/1936-039-03/S0002-9947-1936-1501858-0/S0002-9947-1936-1501858-0.pdf}.


\begin{comment}

\begin{theorem}[Maximum Informativity]
If the expansion produces $t1$, and there exists another possible type choice
$t2$, then $t1 \sim t2$ and $t1 JOIN t2 = t1$
\end{theorem}\footnote{idea is that special casing the holes in EANEHole gives you ``the
most descriptive hole types'' for some sense of what that means -- they'd
all just be hole other wise. from Matt:
\begin{quote}
It sounds like we need a something akin to an abstract domain (a lattice),
where hole has the least information, and a fully-defined type (without
holes) has the most information.  You can imagine that this lattice really
expands the existing definition we have of type consistency, which is
merely the predicate that says whether two types are comparable
(“join-able”) in this lattice.  lattice join is the operation that goes
through the structure of two (consistent) types, and chooses the structure
that is more defined (i.e., non-hole, if given the choice between hole and
non-hole).

The rule choosenonhole below is the expansion of this consistency rule that
we already have (hole consistent with everything)
\end{quote}}

\begin{verbatim}
t not hole
-------------------- :: choose-non-hole
hole JOIN t  = t
\end{verbatim}
\begin{verbatim}
------------ :: hole-consistent-with-everything
hole ~ t
\end{verbatim}

\end{comment}
