% !TEX root = hazelnut-dynamics.tex
%% \newcommand{\examplesSec}{Live Functional Programming in Hazel, By Example}
%% \newcommand{\examplesSec}{Live Programming in \HazelnutLive, By Example}
\newcommand{\examplesSec}{\HazelnutLive, By Example}
\section{\protect\examplesSec} % don't like the all-caps thing that the template does, so protecting it from that
\label{sec:examples}

\newcommand{\overviewExample}[2]{\paragraph{Example {#1}: {#2}}}

We introduce \HazelnutLive{} in this section using several examples,
demonstrating how running incomplete programs---with missing expressions and/or
type-inconsistent expressions---can be useful.
%
We will also demonstrate how running even complete programs with subexpressions
marked as holes may be useful in debugging.

\HazelnutLive{} programs are written in OCaml \cite{leroy03:_ocaml}, using the
alternative Reason syntax \cite{reason-what} extended to support holes.
%
As shown in \autoref{fig:grades-example}, a \HazelnutLive{} notebook is a
literate program \cite{knuth1984literate}: rich text comments appear at the top
level and code appears within cells embedded into these comments.
%
The reader is encouraged to work through these examples in our prototype
implementation or watch video demonstrations, both available in
\suppMaterials{}.\footnote{
%
The programs in this section are written using minor syntactic conveniences that
are not currently supported in our implementation.
%
For example, the implementation of recursive types in our current implementation
requires explicit \texttt{fold} and \texttt{unfold} expressions; these can be
inferred in standard ways (by pairing them with constructors and deconstructors
for algebraic datatypes) in future work.
%
More details about other minor syntactic differences are described in
\suppMaterials{}.
%
}

\input{examples-1}
\input{examples-2}
\input{examples-3}
\input{examples-4}


\paragraph{Recap}
%
In the above four subsections, respectively, we considered programs with:
%
(1) empty expression holes,
%
(2) non-empty expression holes for ill-typed expressions,
%
(3) type holes, and
%
(4) non-empty expression holes for well-typed expressions.
%
Next, we will formally describe the novel dynamic semantics of \HazelnutLive{}
that allows programs with combinations of these kinds of incompleteness to be
evaluated.
