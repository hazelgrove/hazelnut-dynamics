% !TEX root = hazelnut-dynamics.tex
%% \newcommand{\examplesSec}{Live Functional Programming in Hazel, By Example}
%% \newcommand{\examplesSec}{Live Programming in \HazelnutLive, By Example}
\newcommand{\examplesSec}{Live Functional Programming with Typed Holes in Hazel}
\section{\protect\examplesSec} % don't like the all-caps thing that the template does, so protecting it from that
\label{sec:examples}

\input{fig-grades-example}


\newcommand{\overviewExample}[2]{\paragraph{Example {#1}: {#2}}}

This section gives an example-driven overview of our  approach as implemented in  \Hazel, a live programming environment being developed by \citet{HazelnutSNAPL} (initially for use by students and instructors in introductory functional programming courses). The \Hazel user interface is based roughly on IPython/Jupyter \cite{PER-GRA:2007}, with code organized into cells and results appearing below each cell, and the \Hazel language is tracking toward feature parity with \Elm~(\url{elm-lang.org}) \cite{czaplicki2012elm,Elm}, a popular pure functional programming language similar to ``core ML'', with which we assume familiarity.
For the sake of 
exposition, we have post-processed the screenshots in this section after generating them in \Hazel to make use of some ``syntactic and semantic sugar'' from \Elm~that was not available in \Hazel as of this writing, e.g. pattern matching in function arguments, list  notation, and record labels (currently there are only tuples). These conveniences are orthogonal to the contributions of this paper. All of the live programming features demonstrated in the figures in this section have been implemented (see Sec.~\ref{sec:implementation}).

\input{examples-1}
\input{examples-2}
\input{examples-3}
\input{examples-4}


% \paragraph{Recap}
% %
% In the above four subsections, respectively, we considered programs with:
% %
% (1) empty expression holes,
% %
% (2) non-empty expression holes for ill-typed expressions,
% %
% (3) type holes, and
% %
% (4) non-empty expression holes for well-typed expressions.
% %
% Next, we will formally describe the novel dynamic semantics of \HazelnutLive{}
% that allows programs with combinations of these kinds of incompleteness to be
% evaluated.
