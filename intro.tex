% !TEX root = hazelnut-dynamics.tex
\vspace{-7px}
\newcommand{\introSec}{Introduction}
\section{\protect\introSec} % don't like the all-caps thing that the template does, so protecting it from that
\label{sec:intro}
% \vspace{-2px}

% Programming environments often operate in ``batch mode'', assuming that the programmer will spend a substantial amount 
% of time editing the program text blindly before evaluating (i.e. running) the program. 

Programmers typically shift back and forth between program editing and evaluation many times before converging upon a program that behaves correctly. 
Live programming environments support this workflow by interleaving editing and evaluation so as to   
narrow what \citet{burckhardt2013s} call ``the temporal and perceptive gap'' between these activities.
% In other words, the goal \IS to provide continuous feedback about the dynamic behavior of the program, in whole or in part,
% directly alongside the program text itself.

For example, read-evaluate-print loops (REPLs) and derivatives thereof, like the IPython/Jupyter lab notebooks popular in data science~\cite{PER-GRA:2007}, allow the programmer to edit and immediately execute program fragments organized into a sequence of cells. 
Spreadsheets are live functional dataflow environments, with cells organized into a grid \cite{DBLP:journals/jfp/Wakeling07}. 
More specialized examples include live direct manipulation programming environments like SuperGlue
\cite{McDirmid:2007}, \sns{}~\cite{sns-pldi,sns-uist}, and the tools
demonstrated by \citet{victor2012inventing} in his lectures;
%
live user interface frameworks \cite{burckhardt2013s};
%
live image processing languages~\cite{DBLP:journals/vlc/Tanimoto90};
%
and live visual and auditory dataflow languages \cite{DBLP:conf/vl/BurnettAW98}, which can support live coding in an artistic performance.
Editor-integrated debuggers \cite{mccauley2008debugging} and other systems that support editing the state of a running program, like Smalltalk environments \cite{Goldberg:1983cn}, are also live programming environments. 
Live programming, in its various incarnations \cite{DBLP:journals/vlc/Tanimoto90,DBLP:conf/icse/Tanimoto13},
%has been and continues to be an active area of research and development.
has been, and continues to be, an active area of research and development.

% \matt{ ``The problem that specifically motivates this paper'' is a
% really long noun phrase; the sentence is more interesting, IMO, when
% the subject is 'programming languages' and not that noun phrase.  }
%
The problem at the heart of this paper is that
programming languages typically assign meaning only to {complete programs}, i.e. programs that are syntactically well-formed and free of static type and binding errors. A program editor, however, frequently encounters incomplete, and therefore meaningless, editor states. As a result, live feedback either ``flickers in and out'', creating temporal gaps, or it ``goes stale'', i.e. it relies on the most recent complete editor state, creating a perceptive gap because the feedback may not accurately reflect what the programmer is actually seeing and writing in the editor.

In some cases these gaps are momentary, like while the programmer
%\IS entering
enters
a short expression. In other cases, these gaps can persist over substantial lengths of time, such as when there are many branches of a case analysis whose bodies are initially left blank or when the programmer makes a mistake.
%
Novice programmers, of course, make more mistakes \cite{mccauley2008debugging,fitzgerald2008debugging}.
%
%\matt{we are not really modeling a language with user type definitions -- what does the following sentence really add here? also, I just added this scenerio to the list above}
The problem is particularly pronounced for languages with rich static type systems, where certain program changes, such as a change to a type definition, can cause type errors to propagate throughout the program. Throughout the process of addressing these errors, the program text remains formally meaningless. 
Overall, an analysis of edits performed by Java programmers using Eclipse found that about 40\% of edit states were malformed \cite{popl-paper,6883030} and some additional number, which could not be determined from the data, were well-formed but ill-typed.

 % From the perspective of the language definition, these edit states are wholly meaningless, so editor services cannot rely on the same operations and reasoning principles that would be available to, for example, the compiler. 

% Despite these advances, there \IS a fundamental limitation which hinders
% the full realization of live programming: traditional programming languages
% cannot evaluate \emph{incomplete programs}, \ie{}, programs that are either
% syntactically ill-formed, or ill-typed.
% %
% Without a well-defined semantics to dictate the treatment of incomplete
% programs, various editor services may be provided in ad-hoc, restricted
% forms---if available at all---during the periods of time between complete
% program states.
% %
% %% ``flickering in and out''
% %
% %% In other words, the ``Edit-Compile-Run'' cycle routinely fails (either in the
% %% first or second steps) during the program editing process.
% %
% The resulting editor experience includes services ``flickering in and out,''
% thus introducing ``temporal and perceptive gaps'' because programmers often
% leave a program malformed or ill-typed for extended periods of time, \eg{}~as
% they think about what to enter at the cursor, or as they work on a different
% part of the program.
% %
% These times are, arguably, when rich, live editor services would be most helpful
% to the user.

%\matt{ Below, notice the broadening from ``the problem that motivates
%this paper is that incomplete lack dynamic meaing'' to just the
%general quesiton of ``incomplete program meaning''--- another reason
%to do my edit above, and remove that specific phrase.
%}
In recognition of this problem---that incomplete programs lack meaning---%
\citet{popl-paper} develop a static semantics (i.e. a type system) for incomplete 
functional programs, modeling them formally as typed expressions with \emph{holes} in 
both expression and type position. 
Empty holes stand for missing expressions or types,
and non-empty holes operate as ``membranes'' around static type inconsistencies 
(i.e. they internalize the ``red underline'' that editors commonly display under a type inconsistency).
% For editor states into this language of incomplete programs, 
% editor services can reason about types and binding in many more situations than previously possible.
\citet{popl-paper,HazelnutSNAPL} discuss several ways to determine an incomplete expression from an editor state. 
Briefly, error recovery mechanisms can insert the necessary holes implicitly \cite{DBLP:journals/siamcomp/AhoP72,charles1991practical,graham1979practical,DBLP:conf/oopsla/KatsJNV09,DBLP:conf/oopsla/KatsV10},
the programmer can insert explicit holes manually (see below) 
or semi-automatically via code completion techniques \cite{Amorim2016}, 
or a structure editor can insert holes fully automatically \cite{popl-paper} (we say more about this technique in Sec.~\ref{sec:implementation}).
%
For the purposes of live programming, however, a static semantics for incomplete programs does not suffice---%
we also need a corresponding dynamic semantics for incomplete programs that specifies how to evaluate expressions with holes. This paper aims to address this need by developing
a {dynamic semantics} for incomplete functional programs, 
starting from the static semantics of \citet{popl-paper}.
%
%Our goal in this paper \IS to develop

One approach would be to define a dynamic semantics that simply aborts with an error when evaluation reaches a hole. 
%%%%%%%%%%%% New par:
%
This mirrors a workaround to the problem that programmers commonly deploy: 
raising an exception where an expression has yet be determined, e.g. \lismall{raise Unimplemented}. 
Some languages provide more concise notation for this ``encoding'' of expression holes, 
e.g. Scala provides \lismall{???}  
and GHC Haskell with the \lismall{-fdefer-typed-holes} or \lismall{-fdefer-ty}\lismall{pe-errors} flags uses \lismall{_u}
where \lismall{u} serves as an
optional hole name \cite{GHCHoles}.%
\footnote{Without these flags, holes cause compilation to fail. The compiler reports static information about each hole's type and typing context. 
Proof assistants like Agda \cite{norell:thesis,norell2009dependently} and Idris \cite{brady2013idris} also respond to holes in this way.}

Although better than nothing, this approach of stopping with an exception upon reaching an expression hole has limitations 
as the basis for a live programming environment because 
(1)~it provides limited information about the dynamic state of the program when the exception occurs
(typically only a stack trace);  
(2)~it provides no information about the behavior of the remainder of program, 
parts of which may not depend on the missing or erroneous expression (e.g. later cells in a lab notebook); and 
(3)~it provides no means by which to resume evaluation after filling a hole.

Moreover, we need to be able to run programs containing not only expression holes but also type holes.
The static semantics developed by \citet{popl-paper} derives the machinery for 
reasoning statically about type holes from gradual type theory, 
identifying the type hole with the unknown type \cite{DBLP:conf/snapl/SiekVCB15,Siek06a}.
%
As such, we can look to the dynamic semantics from
gradual type theory to specify the dynamic semantics for incomplete programs,
which selectively inserts dynamic casts as necessitated by missing type information to maintain type safety. 
%However, this \IS again somewhat dissatisfying from the perspective of live programming because when a cast fails, evaluation again stops with 
However, when a cast fails, evaluation again stops with 
an exception.
%
As a result, traditional gradual typing approaches still leave the live programming environment unable to provide feedback about the parts 
of the program that do not depend on the problematic sub-expression.


\parahead{Contributions}

This paper develops a theoretically well-grounded dynamic semantics for incomplete functional programs that addresses the limitations of the ``exceptional approach'' just described. 
In particular, rather than stopping with an exception when evaluation encounters an expression hole, evaluation continues ``around'' the hole, performing as much of the remaining computation as possible. 
Evaluation also proceeds past failed casts in much the same way. 
The system tracks the environment around each hole instance as evaluation proceeds. 
The live programming environment can feed relevant information from these hole environments to the programmer as they work to fill the holes in the program. 
Then, when the programmer performs an edit that fills an empty expression hole or that replaces a non-empty hole with a type-correct expression, evaluation can resume from the paused, i.e. \emph{indeterminate}, evaluation state.

\parahead{Paper Outline}

\newcommand{\contribution}[2]{\paragraph{#1. #2}} 

We are integrating this approach into the \Hazel programming environment being developed (separately from this paper) by \citet{HazelnutSNAPL}. 
We begin in Sec.~\ref{sec:examples} by detailing the approach informally, with several examples, in the setting of this specific design.

Sec.~\ref{sec:calculus} then abstracts away orthogonal details of the language and user interface and makes these intuitions formally precise by detailing the primary contribution of this paper: a core calculus, \HazelnutLive, that supports evaluating incomplete expressions as just outlined, in a manner that admits clean type safety theorems (in particular, a Progress theorem). The semantics of \HazelnutLive borrows machinery from gradual type theory~\cite{DBLP:conf/snapl/SiekVCB15}
(to handle incomplete types) and contextual modal type theory~\cite{Nanevski2008} (CMTT,
which provides a logical foundation for hole environment tracking). 
These non-obvious connections to well-established existing systems help support our claim that this approach is theoretically well-grounded\todo{note that our exposition \IS self-contained here? or later?}.

Sec.~\ref{sec:agda-mechanization} outlines our mechanization of the core calculus using the Agda proof assistant. 
Sec.~\ref{sec:implementation} outlines our simple implementation of the core calculus, which implements the live programming features from Sec.~\ref{sec:examples},
but for the more austere language of Sec.~\ref{sec:calculus}. 
The editor component of this implementation provides a language of structured edit actions, 
based on the \Hazelnut structure editor calculus developed by \cite{popl-paper}, that guarantees that
every editor state has some, possibly incomplete, type. 
Together with the theorems established earlier in Sec.~\ref{sec:calculus}, the result is a proof-of-concept
live functional programming environment where every possible editor state has both non-trivial static and dynamic 
meaning, i.e. live feedback never ``flickers'' or ``goes out''. 
The supplemental material includes both the mechanization and the implementation.

Sec.~\ref{sec:resumption} defines the fill-and-resume feature, which is rooted in the contextual substitution operation from CMTT. We establish the correctness of fill-and-resume with a novel commutativity property and discuss how it provides a semantic interpretation of cells in a live lab notebook environment.

Sec.~\ref{sec:relatedWork} describes related work in more detail and simultaneously discusses directions for future work. Sec.~\ref{sec:discussion} briefly concludes. The appendix includes some straightforward auxiliary definitions and proofs mentioned in the paper, some extensions to the core calculus, and some screenshots and additional details on the implementation. 