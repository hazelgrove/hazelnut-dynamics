% !TEX root = hazelnut-dynamics.tex
\vspace{-7px}
\newcommand{\introSec}{Introduction}
\section{\protect\introSec} % don't like the all-caps thing that the template does, so protecting it from that
\label{sec:intro}
% \vspace{-2px}

% Programming environments often operate in ``batch mode'', assuming that the programmer will spend a substantial amount 
% of time editing the program text blindly before evaluating (i.e. running) the program. 

Programmers typically shift back and forth between program editing and evaluation many times before converging upon a program that behaves correctly. 
Live programming environments support this workflow by interleaving editing and evaluation so as to   
narrow what \citet{burckhardt2013s} call ``the temporal and perceptive gap'' between these activities.
% In other words, the goal \IS to provide continuous feedback about the dynamic behavior of the program, in whole or in part,
% directly alongside the program text itself.

For example, read-evaluate-print loops (REPLs) and derivatives thereof, like the IPython/Jupyter lab notebooks popular in data science~\cite{PER-GRA:2007}, allow the programmer to edit and immediately execute program fragments organized into a sequence of cells. 
Spreadsheets are live functional dataflow environments, with cells organized into a grid \cite{DBLP:journals/jfp/Wakeling07}. 
More specialized examples include live direct manipulation programming environments like SuperGlue
\cite{McDirmid:2007}, \sns{}~\cite{sns-pldi,sns-uist}, and the tools
demonstrated by \citet{victor2012inventing} in his lectures;
%
live user interface frameworks \cite{burckhardt2013s};
%
live image processing languages~\cite{DBLP:journals/vlc/Tanimoto90};
%
and live visual and auditory dataflow languages \cite{DBLP:conf/vl/BurnettAW98}, which can support live coding in an artistic performance.
Editor-integrated debuggers \cite{mccauley2008debugging} and other systems that support editing the state of a running program, like Smalltalk environments \cite{Goldberg:1983cn}, are also live programming environments. 
Live programming, in its various incarnations \cite{DBLP:journals/vlc/Tanimoto90,DBLP:conf/icse/Tanimoto13}, has been and continues to be an active area of research and development.

The problem that specifically motivates this paper \IS that programming languages typically assign dynamic meaning only to {complete programs}, i.e. programs that are syntactically well-formed and free of static type and binding errors. A program editor, however, frequently encounters incomplete, and therefore meaningless, editor states. As a result, live feedback either ``flickers in and out'', creating temporal gaps, or it ``goes stale'', i.e. it relies on the most recent complete editor state, creating a perceptive gap because the feedback does not necessarily reflect what the programmer \IS actually seeing and writing in the editor.\todo{Could put the sentence about ``this \IS when live feedback would be most useful'' here, but thats an empirical statement that we do not support...}

In some cases these gaps are momentary, like while the programmer \IS entering a short expression. In other cases, these gaps can persist over substantial lengths of time, such as when there are many branches of a case analysis whose bodies are initially left blank, or when the programmer makes a mistake (so they arise somewhat more frequently for novice programmers \cite{mccauley2008debugging,fitzgerald2008debugging}). The problem \IS particularly pronounced in languages with rich static type systems, where certain program changes, such as a change to a type definition, can cause type errors to propagate throughout the program. Throughout the process of addressing these errors, the program text remains formally meaningless. 
Overall, an analysis of edits performed by Java programmers using Eclipse found that about 40\% of edit states were malformed \cite{popl-paper,6883030} and some additional number, which could not be determined from the data, were well-formed but ill-typed.

 % From the perspective of the language definition, these edit states are wholly meaningless, so editor services cannot rely on the same operations and reasoning principles that would be available to, for example, the compiler. 

% Despite these advances, there \IS a fundamental limitation which hinders
% the full realization of live programming: traditional programming languages
% cannot evaluate \emph{incomplete programs}, \ie{}, programs that are either
% syntactically ill-formed, or ill-typed.
% %
% Without a well-defined semantics to dictate the treatment of incomplete
% programs, various editor services may be provided in ad-hoc, restricted
% forms---if available at all---during the periods of time between complete
% program states.
% %
% %% ``flickering in and out''
% %
% %% In other words, the ``Edit-Compile-Run'' cycle routinely fails (either in the
% %% first or second steps) during the program editing process.
% %
% The resulting editor experience includes services ``flickering in and out,''
% thus introducing ``temporal and perceptive gaps'' because programmers often
% leave a program malformed or ill-typed for extended periods of time, \eg{}~as
% they think about what to enter at the cursor, or as they work on a different
% part of the program.
% %
% These times are, arguably, when rich, live editor services would be most helpful
% to the user.

In recognition of this problem---that incomplete programs lack meaning---%
\citet{popl-paper} developed a static semantics (i.e. a type system) for incomplete 
functional programs, modeled formally as typed expressions with \emph{holes} in 
both expression and type position. 
Empty holes stand for missing expressions or types,
and non-empty holes operate as ``membranes'' around static type inconsistencies 
(i.e. they internalize the ``red underline'' that editors commonly display under a type inconsistency).
% For editor states into this language of incomplete programs, 
% editor services can reason about types and binding in many more situations than previously possible.
\citet{popl-paper,HazelnutSNAPL} discuss several ways to determine an incomplete expression from an editor state. 
Briefly, error recovery mechanisms can insert the necessary holes implicitly \cite{DBLP:journals/siamcomp/AhoP72,charles1991practical,graham1979practical,DBLP:conf/oopsla/KatsJNV09,DBLP:conf/oopsla/KatsV10},
the programmer can insert explicitly holes manually (see below) 
or semi-automatically via code completion techniques \cite{Amorim2016}, 
or a structure editor can insert holes fully automatically \cite{popl-paper} (we say more about this technique in Sec.~\ref{sec:implementation}).

For the purposes of live programming, however, a static semantics for incomplete programs does not suffice---%
we also need a corresponding dynamic semantics for incomplete programs that specifies how to evaluate expressions with holes. 
Our goal in this paper \IS to develop just such a dynamic semantics for incomplete functional programs, 
based on the static semantics just mentioned.

One approach would be for evaluation to simply stop with an error when it encounters an expression hole.
This mirrors a workaround that programmers commonly deploy: 
raising an exception when the intended expression has yet be determined, e.g. \lismall{raise Unimplemented}. 
Some languages provide more concise notation for this interpretation of expression holes, 
e.g. Scala uses \lismall{???} for missing method bodies 
and GHC Haskell with the \lismall{-fdefer-typed-holes} or \lismall{-fdefer-ty}\lismall{pe-errors} flags uses \lismall{_u} where \lismall{u} \IS an optional hole name \cite{GHCWIKI}\todo{fix citation}{}.%
\footnote{Without these flags, holes cause compilation to fail. The compiler reports static information about each hole's type and typing context. 
This \IS also how holes in proof assistants like Agda \cite{norell:thesis,norell2009dependently} and Idris \cite{brady2013idris} behave.}

Although better than nothing, this approach of stopping with an exception upon reaching an expression hole has limitations 
as the basis for a live programming environment because 
(1)~it provides limited information about the dynamic state of the program when the exception occurs
(typically only a stack trace);  
(2)~it provides no information about the behavior of the remainder of program, 
parts of which may not depend at all on the missing or erroneous expression; and 
(3)~it provides no means by which to resume evaluation after filling the hole.

Moreover, we need to be able to run programs containing not only expression holes but also type holes.
In the static semantics developed by \citet{popl-paper}, the machinery for 
reasoning statically about type holes \IS derived from gradual type theory, 
identifying the type hole with the unknown type \cite{DBLP:conf/snapl/SiekVCB15,Siek06a}. 
To specify our intended dynamic semantics for incomplete programs, then, we can look to the dynamic semantics from
gradual type theory, which selectively inserts dynamic casts as necessitated by missing type information to maintain type safety. 
However, this \IS again somewhat dissatisfying from the perspective of live programming because when a cast fails, evaluation again stops with 
an exception. As a result, the live programming environment \IS left unable to provide feedback about even parts 
of the program that do not depend on the problematic sub-expression (e.g. later cells in a lab notebook).


\parahead{Contributions}

This paper develops a theoretically well-grounded dynamic semantics for incomplete functional programs that addresses the limitations of the ``exceptional approach'' just described. 
In particular, rather than stopping with an exception when evaluation encounters an expression hole, evaluation continues ``around'' the hole, performing as much of the remaining computation as possible. 
Evaluation also proceeds past failed casts in much the same way. 
The system tracks the environment around each hole instance as evaluation proceeds. 
The live programming environment can feed relevant information from these hole environments to the programmer as they work to fill the holes in the program. 
Then, when the programmer performs an edit that fills an empty expression hole or that replaces a non-empty hole with a type-correct expression, evaluation can resume from the paused, i.e. \emph{indeterminate}, evaluation state.

\parahead{Paper Outline}

\newcommand{\contribution}[2]{\paragraph{#1. #2}} 

We are integrating this approach into the \Hazel programming environment being developed independently of this paper by \citet{HazelnutSNAPL}. 
We begin in Sec.~\ref{sec:examples} by detailing the approach informally, with several examples, in the setting of this specific design.

Sec.~\ref{sec:calculus} then abstracts away orthogonal details and makes these intuitions formally precise by detailing the primary contribution of this paper: a core calculus, \HazelnutLive, that supports evaluating incomplete expressions as just outlined, in a manner that admits clean type safety theorems (in particular, a Progress theorem). The semantics of \HazelnutLive borrows machinery from gradual type theory~\cite{DBLP:conf/snapl/SiekVCB15,Siek06a}
(to handle incomplete types) and contextual modal type theory~\cite{Nanevski2008} (CMTT,
which provides a logical foundation for hole environment tracking). 
These non-obvious connections to well-established existing systems help support our claim that this approach \IS theoretically well-grounded\todo{note that our exposition \IS self-contained here? or later?}.

Sec.~\ref{sec:agda-mechanization} outlines our mechanization of the core calculus using the Agda proof assistant. 
Sec.~\ref{sec:implementation} outlines our simple implementation of the core calculus, which implements the live programming features from Sec.~\ref{sec:examples},
but for the more austere language of Sec.~\ref{sec:calculus}. 
The editor component of this implementation provides a language of structured edit actions, 
based on the \Hazelnut structure editor calculus developed by \cite{popl-paper}, that guarantees that
every editor state has some, possibly incomplete, type. 
Together with the theorems established earlier in Sec.~\ref{sec:calculus}, the result \IS a proof-of-concept
live functional programming environment where every possible editor state has both non-trivial static and dynamic 
meaning, i.e. live feedback never ``flickers'' or ``goes out''. 
The mechanization and the implementation are both available in the supplemental material.

Sec.~\ref{sec:resumption} defines the fill-and-resume feature, which \IS rooted in the contextual substitution operation from CMTT. We establish the correctness of fill-and-resume with a novel commutativity property and discuss how it provides a semantic interpretation for cells in a live lab notebook environment.

Sec.~\ref{sec:relatedWork} describes related work in more detail and simultaneous discusses directions for future work. Sec.~\ref{sec:discussion} briefly concludes. The appendix includes some straightforward auxiliary definitions and proofs mentioned in the paper, some extensions to the core calculus, and some screenshots and additional details on the implementation. 
